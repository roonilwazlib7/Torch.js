// Generated by CoffeeScript 1.10.0
(function() {
  var AjaxLoader, ArrayUtility, Event, FunctionUtility, ObjectUtility, StringUtility, Task, Torch, Utilities, exports,
    slice = [].slice;

  exports = this;

  window.onerror = function() {
    var args, errorObj;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (!window.Torch.STRICT_ERRORS) {
      return;
    }
    errorObj = args[4];
    if (errorObj !== void 0) {
      return window.Torch.FatalError(errorObj);
    } else {
      return window.Torch.FatalError("An error has occured");
    }
  };

  Task = (function() {
    Task.MixIn(Trashable);

    Task.prototype._torch_add = "Task";

    function Task(func1) {
      this.func = func1;
    }

    Task.prototype.Execute = function(game) {
      return this.func(game);
    };

    return Task;

  })();

  AjaxLoader = (function() {
    AjaxLoader.prototype.onFinish = function() {};

    AjaxLoader.prototype.onError = function() {};

    function AjaxLoader(url, responseType) {
      if (responseType == null) {
        responseType = window.Torch.AjaxData.Text;
      }
      this.url = url;
      this.responseType = this.GetResponseTypeString(responseType);
    }

    AjaxLoader.prototype.GetResponseTypeString = function(responseType) {
      switch (responseType) {
        case window.Torch.AjaxData.DOMString:
          return "";
        case window.Torch.AjaxData.ArrayBuffer:
          return "arraybuffer";
        case window.Torch.AjaxData.Blob:
          return "blob";
        case window.Torch.AjaxData.Document:
          return "document";
        case window.Torch.AjaxData.Json:
          return "json";
        case window.Torch.AjaxData.Text:
          return "text";
      }
    };

    AjaxLoader.prototype.Error = function(func) {
      return this.onError = func;
    };

    AjaxLoader.prototype.Finish = function(func) {
      return this.onFinish = func;
    };

    AjaxLoader.prototype.Load = function() {
      var request;
      request = new XMLHttpRequest();
      request.open('GET', this.url, true);
      request.responseType = this.responseType;
      request.onload = (function(_this) {
        return function() {
          return _this.onFinish(request.response, _this);
        };
      })(this);
      return request.send();
    };

    return AjaxLoader;

  })();

  Event = (function() {
    function Event(game1, data) {
      var key, ref, value;
      this.game = game1;
      this.data = data;
      if (this.game !== null) {
        this.time = this.game.time;
      }
      ref = this.data;
      for (key in ref) {
        value = ref[key];
        this[key] = value;
      }
    }

    return Event;

  })();

  Torch = (function() {
    var Is;

    Torch.prototype.CANVAS = 1;

    Torch.prototype.WEBGL = 2;

    Torch.prototype.PIXEL = 3;

    Torch.prototype.DUMP_ERRORS = false;

    function Torch() {
      this.GamePads = this.Enum("Pad1", "Pad2", "Pad3", "Pad4");
      this.AjaxData = this.Enum("DOMString", "ArrayBuffer", "Blob", "Document", "Json", "Text");
      this.Types = this.Enum("String", "Number", "Object", "Array", "Function", "Sprite", "Game", "Null");
      this.AjaxLoader = AjaxLoader;
      this.Event = Event;
      this.EventDispatcher = EventDispatcher;
      this.Trashable = Trashable;
      this.Util = new Utilities();
    }

    Torch.prototype.RandomInRange = function(min, max) {
      return Math.random() * (max - min + 1) + min;
    };

    Torch.prototype.Needs = function(key) {
      if (!Torch[key]) {
        throw "Compenent " + key + " is required";
      }
      return this;
    };

    Torch.prototype.FatalError = function(error) {
      var errorHtml, stack;
      if (this.fatal) {
        return;
      }
      this.fatal = true;
      if (typeof error === "string") {
        error = new Error(error);
      }
      document.body.backgroundColor = "black";
      if (this.DUMP_ERRORS) {
        if (require !== void 0) {
          require("fs").writeFileSync("torch-error.log", error.stack);
        }
      }
      stack = error.stack.replace(/\n/g, "<br><br>");
      errorHtml = "<code style='color:#C9302C;margin-left:15%;font-size:24px'>" + error + "</code>\n<br>\n<code style='color:#C9302C;font-size:20px;font-weight:bold'>Stack Trace:</code><br>\n<code style='color:#C9302C;font-size:20px'>" + stack + "</code><br>";
      document.body.innerHTML = errorHtml;
      throw error;
    };

    Torch.prototype.StrictErrors = function() {
      return this.STRICT_ERRORS = true;
    };

    Torch.prototype.DumpErrors = function() {
      return this.DUMP_ERRORS = true;
    };

    Torch.prototype.DisableConsoleWarnings = function() {
      return console.warn = function() {};
    };

    Torch.prototype.Enum = function() {
      var i, j, len, obj, part, parts;
      parts = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      obj = {};
      for (i = j = 0, len = parts.length; j < len; i = ++j) {
        part = parts[i];
        obj[part] = i + 1;
      }
      return obj;
    };

    Torch.prototype.Assert = function(expression, errorTag) {
      if (errorTag == null) {
        errorTag = "Assertation Failed";
      }
      if (!expression) {
        return Torch.FatalError(errorTag);
      }
    };

    Torch.prototype.TypeOf = function(obj) {
      var objTypes, typeString;
      objTypes = [];
      if (obj.__torch__ !== void 0) {
        objTypes.push(obj.__torch__);
      }
      typeString = {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
      switch (typeString) {
        case "string":
          objTypes.push(Torch.Types.String);
          break;
        case "number":
          objTypes.push(Torch.Types.Number);
          break;
        case "object":
          objTypes.push(Torch.Types.Object);
          break;
        case "array":
          objTypes.push(Torch.Types.Array);
          break;
        case "function":
          objTypes.push(Torch.Types.Function);
          break;
        default:
          objTypes.push(Torch.Types.Null);
      }
      return objTypes;
    };

    Is = function(obj, torchType) {
      return Torch.TypeOf(obj).indexOf(torchType) !== -1;
    };

    Torch.prototype.ExtendObject = function(objectToExtend, newObject) {
      var key, results, value;
      results = [];
      for (key in newObject) {
        value = newObject[key];
        results.push(objectToExtend[key] = value);
      }
      return results;
    };

    Torch.prototype.ExtendProperties = function() {
      var Class, func, j, keyProp, len, prop, properties, results;
      Class = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      results = [];
      for (j = 0, len = properties.length; j < len; j++) {
        prop = properties[j];
        keyProp = prop.unCapitalize();
        func = function(arg) {
          if (arg === void 0) {
            return this[keyProp];
          }
          this[keyProp] = arg;
          return this;
        };
        results.push(Class.prototype[prop] = func);
      }
      return results;
    };

    return Torch;

  })();

  Utilities = (function() {
    function Utilities() {}

    Utilities.prototype.Expose = function() {
      return window["T"] = this;
    };

    Utilities.prototype.RandomInRange = function() {};

    Utilities.prototype.String = function(str) {
      return new StringUtility(str);
    };

    Utilities.prototype.Array = function(array) {
      return new ArrayUtility(array);
    };

    Utilities.prototype.Function = function(func) {
      return new FunctionUtility(func);
    };

    Utilities.prototype.Object = function(obj) {
      return new ObjectUtility(obj);
    };

    return Utilities;

  })();

  StringUtility = (function() {
    function StringUtility(str1) {
      this.str = str1;
    }

    StringUtility.prototype.String = function() {
      return this.str;
    };

    StringUtility.prototype.Chunk = function(chunkLength) {
      this.str = this.str.match(new RegExp('.{1,' + chunkLength + '}', 'g'));
      return this.str;
    };

    StringUtility.prototype.Capitalize = function() {
      this.str[0] = this.str[0].toUpperCase();
      return this.str;
    };

    return StringUtility;

  })();

  ArrayUtility = (function() {
    function ArrayUtility(array1) {
      this.array = array1;
    }

    ArrayUtility.prototype.Array = function() {
      return this.array;
    };

    ArrayUtility.prototype.All = function(applier) {
      var item, j, len, ref, results;
      ref = this.array;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        results.push(applier(item));
      }
      return results;
    };

    ArrayUtility.prototype.Find = function(selector) {
      var item, j, len, ref;
      ref = this.array;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        if (selector(item)) {
          return item;
        }
      }
    };

    ArrayUtility.prototype.Filter = function(selector) {
      var item, j, len, ref, selectedItems;
      selectedItems = [];
      ref = this.array;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        if (selector(item)) {
          selectedItems.push(item);
        }
      }
      return selectedItems;
    };

    ArrayUtility.prototype.Reject = function(selector) {
      var item, j, len, ref, selectedItems;
      selectedItems = [];
      ref = this.array;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        if (!selector(item)) {
          selectedItems.push(item);
        }
      }
      return selectedItems;
    };

    ArrayUtility.prototype.Where = function(properties) {
      var items;
      items = this.Filter(function(item) {
        var key, value;
        for (key in properties) {
          value = properties[key];
          if (item[key] !== value) {
            return false;
          }
        }
        return true;
      });
      return items;
    };

    ArrayUtility.prototype.Every = function(selector) {
      var item, j, len, ref;
      ref = this.array;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        if (!selector(item)) {
          return false;
        }
      }
      return true;
    };

    ArrayUtility.prototype.Some = function(selector) {
      var item, j, len, ref;
      ref = this.array;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        if (selector(item)) {
          return true;
        }
      }
      return false;
    };

    ArrayUtility.prototype.Contains = function(item, startIndex) {
      var index;
      if (startIndex == null) {
        startIndex = 0;
      }
      index = this.array.indexOf(item);
      return index !== -1 && index >= startIndex;
    };

    ArrayUtility.prototype.Pluck = function(propertyName) {
      var item, j, len, properties, ref;
      properties = [];
      ref = this.array;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        properties.push(item[propertyName]);
      }
      return properties;
    };

    ArrayUtility.prototype.Max = function(selector) {
      var compareValue, currentMax, item, j, len, ref;
      currentMax = 0;
      if (selector == null) {
        selector = function(item) {
          return item;
        };
      }
      ref = this.array;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        compareValue = selector(item);
        if (compareValue > currentMax) {
          currentMax = item;
        }
      }
      return currentMax;
    };

    ArrayUtility.prototype.Min = function(selector) {
      var compareValue, currentMin, item, j, len, ref;
      currentMin = 0;
      if (selector == null) {
        selector = function(item) {
          return item;
        };
      }
      ref = this.array;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        compareValue = selector(item);
        if (compareValue < currentMin) {
          currentMin = compareValue;
        }
      }
      return currentMin;
    };

    ArrayUtility.prototype.SortBy = function(sorter) {};

    ArrayUtility.prototype.GroupBy = function(grouper) {
      var group, groups, item, j, len, ref;
      if (grouper == null) {
        grouper = function(item) {
          return item.toString().length;
        };
      }
      groups = {};
      ref = this.array;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        group = grouper(item);
        if (groups[group] == null) {
          groups[group] = [item];
        } else {
          groups[group].push(item);
        }
      }
      return groups;
    };

    ArrayUtility.prototype.CountBy = function(grouper) {
      var groups, key, value;
      groups = this.GroupBy(grouper);
      for (key in groups) {
        value = groups[key];
        groups[key] = value.length;
      }
      return groups;
    };

    ArrayUtility.prototype.Shuffle = function() {
      var currentIndex, randomIndex, temporaryValue;
      currentIndex = this.array.length;
      temporaryValue = currentIndex;
      randomIndex = currentIndex;
      while (0 !== currentIndex) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        temporaryValue = this.array[currentIndex];
        this.array[currentIndex] = this.array[randomIndex];
        this.array[randomIndex] = temporaryValue;
      }
      return this.array;
    };

    ArrayUtility.prototype.Sample = function(n) {
      var results, sample;
      if (n == null) {
        n = 1;
      }
      sample = [];
      results = [];
      while (n > 0) {
        results.push(n--);
      }
      return results;
    };

    ArrayUtility.prototype.Partition = function(checker) {
      return [this.Filter(checker), this.Reject(checker)];
    };

    ArrayUtility.prototype.First = function(n) {
      var items;
      if (n == null) {
        n = 1;
      }
      if (n === 1) {
        return this.array[0];
      }
      items = [];
      while (n <= this.array.length) {
        items.push(this.array[n - 1]);
        n++;
      }
      return items;
    };

    ArrayUtility.prototype.Last = function(n) {
      var items;
      if (n == null) {
        n = 1;
      }
      if (n === 1) {
        return this.array[this.array.length - 1];
      }
      items = [];
      while (n <= this.array.length) {
        items.push(this.array[this.array.length - (n - 1)]);
        n++;
      }
      return items;
    };

    ArrayUtility.prototype.Flatten = function() {};

    ArrayUtility.prototype.Without = function() {
      var filteredItems, item, j, len, ref, values;
      values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      filteredItems = [];
      ref = this.array;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        if (values.indexOf(item) === -1) {
          filteredItems.push(item);
        }
      }
      return filteredItems;
    };

    ArrayUtility.prototype.Union = function() {
      var ar, arrays, ars, combinedArray, item, j, k, len, len1;
      arrays = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ars = [this.array].concat(slice.call(arrays));
      combinedArray = [];
      for (j = 0, len = ars.length; j < len; j++) {
        ar = ars[j];
        for (k = 0, len1 = ar.length; k < len1; k++) {
          item = ar[k];
          if (combinedArray.indexOf(item) === -1) {
            combinedArray.push(item);
          }
        }
      }
      return combinedArray;
    };

    ArrayUtility.prototype.Intersection = function() {
      var ar, arrays, ars, combinedArray, index, item, j, k, key, len, len1, value;
      arrays = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ars = [this.array].concat(slice.call(arrays));
      combinedArray = [];
      index = {};
      for (j = 0, len = ars.length; j < len; j++) {
        ar = ars[j];
        for (k = 0, len1 = ar.length; k < len1; k++) {
          item = ar[k];
          if (index[item] == null) {
            index[item] = 1;
          } else {
            index[item] += 1;
          }
        }
      }
      for (key in index) {
        value = index[key];
        if (value >= arrays.length) {
          combinedArray.push(key);
        }
      }
      return combinedArray;
    };

    ArrayUtility.prototype.Uniq = function() {};

    ArrayUtility.prototype.Zip = function() {
      var ar, arrays, combinedArray, index, item, j, k, len, len1, piece, ref;
      arrays = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      combinedArray = [];
      ref = this.array;
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        item = ref[index];
        piece = [item];
        for (k = 0, len1 = arrays.length; k < len1; k++) {
          ar = arrays[k];
          piece.push(ar[index]);
        }
        combinedArray.push(piece);
      }
      return combinedArray;
    };

    ArrayUtility.prototype.UnZip = function() {
      var arrays;
      arrays = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    };

    return ArrayUtility;

  })();

  FunctionUtility = (function() {
    function FunctionUtility(func1) {
      this.func = func1;
    }

    FunctionUtility.prototype.Defer = function() {
      var args, f;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      f = (function(_this) {
        return function() {
          return _this.func.apply(_this, args);
        };
      })(this);
      return setTimeout(f, 0);
    };

    FunctionUtility.prototype.Once = function() {
      var newFunc, oldFunc;
      oldFunc = this.func;
      newFunc = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (this.called) {
          return;
        }
        oldFunc.apply(null, args);
        return this.called = true;
      };
      return newFunc;
    };

    FunctionUtility.prototype.After = function(timesBeforeExecuted) {
      var newFunc, oldFunc;
      oldFunc = this.func;
      newFunc = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        this.timesBeforeExecuted += 1;
        if (this.calledCount < timesBeforeExecuted) {
          return;
        }
        oldFunc.apply(null, args);
        return this.called = true;
      };
      newFunc.timesBeforeExecuted = 0;
      return newFunc;
    };

    FunctionUtility.prototype.Before = function(timesExecuted) {
      var newFunc, oldFunc;
      oldFunc = this.func;
      newFunc = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        this.timesExecuted += 1;
        if (this.calledCount > timesExecuted) {
          return;
        }
        oldFunc.apply(null, args);
        return this.called = true;
      };
      newFunc.timesExecuted = 0;
      return newFunc;
    };

    FunctionUtility.prototype.Compose = function() {
      var allFuncs, funcs, i, newFunc;
      funcs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      allFuncs = [this.func].concat(slice.call(funcs));
      i = 0;
      newFunc = function() {
        var lastReturn, results;
        lastReturn = void 0;
        results = [];
        while (i < allFuncs.length) {
          lastReturn = allFuncs[i](lastReturn);
          results.push(i++);
        }
        return results;
      };
      return newFunc;
    };

    return FunctionUtility;

  })();

  ObjectUtility = (function() {
    function ObjectUtility(obj1) {
      this.obj = obj1;
    }

    ObjectUtility.prototype.Keys = function() {
      var key, keys, ref, value;
      keys = [];
      ref = this.obj;
      for (key in ref) {
        value = ref[key];
        keys.push(key);
      }
      return keys;
    };

    ObjectUtility.prototype.Values = function() {
      var key, ref, value, values;
      values = [];
      ref = this.obj;
      for (key in ref) {
        value = ref[key];
        values.push(value);
      }
      return values;
    };

    ObjectUtility.prototype.All = function(applier) {
      var key, ref, value;
      ref = this.obj;
      for (key in ref) {
        value = ref[key];
        this.obj[key] = applier(key, value);
      }
      return this.obj;
    };

    ObjectUtility.prototype.Invert = function() {
      var key, newObj, ref, value;
      newObj = {};
      ref = this.obj;
      for (key in ref) {
        value = ref[key];
        newObj[value] = key;
      }
      return newObj;
    };

    ObjectUtility.prototype.Functions = function() {
      var functionList, key, ref, value;
      functionList = [];
      ref = this.obj;
      for (key in ref) {
        value = ref[key];
        if (typeof value === "function") {
          functionList.push(value.name);
        }
      }
      return functionList;
    };

    ObjectUtility.prototype.Extend = function() {
      var j, key, len, obj, objects, value;
      objects = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      for (j = 0, len = objects.length; j < len; j++) {
        obj = objects[j];
        for (key in obj) {
          value = obj[key];
          this.obj[key] = value;
        }
      }
      return this.obj;
    };

    ObjectUtility.prototype.Pick = function() {
      var j, key, len, newObj, pickKeys, ref, value;
      pickKeys = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      newObj = {};
      if (typeof pickKeys === "function") {
        ref = this.obj;
        for (key in ref) {
          value = ref[key];
          if (pickKeys(key, value, this.obj)) {
            newObj[key] = value;
          }
        }
      } else {
        for (j = 0, len = pickKeys.length; j < len; j++) {
          key = pickKeys[j];
          newObj[key] = this.obj[key];
        }
      }
      return newObj;
    };

    ObjectUtility.prototype.Omit = function() {
      var key, newObj, omitKeys, ref, ref1, value;
      omitKeys = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      newObj = {};
      if (typeof omitKeys === "function") {
        ref = this.obj;
        for (key in ref) {
          value = ref[key];
          if (!omitKeys(key, value, this.obj)) {
            newObj[key] = value;
          }
        }
      } else {
        ref1 = this.obj;
        for (key in ref1) {
          value = ref1[key];
          if (omitKeys.indexOf(key) === -1) {
            newObj[key] = this.obj[key];
          }
        }
      }
      return newObj;
    };

    ObjectUtility.prototype.Clone = function() {};

    ObjectUtility.prototype.Has = function(key) {
      if (this.obj[key] == null) {
        return false;
      }
      return true;
    };

    ObjectUtility.prototype.Matches = function(otherObj) {
      var key, value;
      for (key in otherObj) {
        value = otherObj[key];
        if (this.obj[key] !== value) {
          return false;
        }
      }
      return true;
    };

    ObjectUtility.prototype.Empty = function() {
      return this.Keys().length === 0;
    };

    return ObjectUtility;

  })();

  exports.Torch = new Torch();

}).call(this);
