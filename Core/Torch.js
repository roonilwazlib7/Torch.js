// Generated by CoffeeScript 1.10.0
(function() {
  var AjaxLoader, Event, Task, Torch, exports,
    slice = [].slice;

  exports = this;

  window.onerror = function() {
    var args, errorObj;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (!window.Torch.STRICT_ERRORS) {
      return;
    }
    errorObj = args[4];
    if (errorObj !== void 0) {
      return window.Torch.FatalError(errorObj);
    } else {
      return window.Torch.FatalError("An error has occured");
    }
  };

  Task = (function() {
    Task.MixIn(Trashable);

    Task.prototype._torch_add = "Task";

    function Task(func1) {
      this.func = func1;
    }

    Task.prototype.Execute = function(game) {
      return this.func(game);
    };

    return Task;

  })();

  AjaxLoader = (function() {
    AjaxLoader.prototype.onFinish = function() {};

    AjaxLoader.prototype.onError = function() {};

    function AjaxLoader(url, responseType) {
      if (responseType == null) {
        responseType = Torch.AjaxData.DOMString;
      }
      this.url = url;
      this.responseType = this.GetResponseTypeString(responseType);
    }

    AjaxLoader.prototype.GetResponseTypeString = function(responseType) {
      switch (responseType) {
        case Torch.AjaxData.DOMString:
          return "";
        case Torch.AjaxData.ArrayBuffer:
          return "arraybuffer";
        case Torch.AjaxData.Blob:
          return "blob";
        case Torch.AjaxData.Document:
          return "document";
        case Torch.AjaxData.Json:
          return "json";
        case Torch.AjaxData.Text:
          return "text";
      }
    };

    AjaxLoader.prototype.Error = function(func) {
      var onError;
      return onError = func;
    };

    AjaxLoader.prototype.Finish = function(func) {
      var onFinish;
      return onFinish = func;
    };

    AjaxLoader.prototype.Load = function() {
      var request;
      request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.responseType = this.responseType;
      request.onload = (function(_this) {
        return function() {
          return _this.onFinish(request.response);
        };
      })(this);
      return request.send();
    };

    return AjaxLoader;

  })();

  Event = (function() {
    function Event(game1, data) {
      var key, ref, value;
      this.game = game1;
      this.data = data;
      if (this.game !== null) {
        this.time = this.game.time;
      }
      ref = this.data;
      for (key in ref) {
        value = ref[key];
        this[key] = value;
      }
    }

    return Event;

  })();

  Torch = (function() {
    Torch.prototype.CANVAS = 1;

    Torch.prototype.WEBGL = 2;

    Torch.prototype.PIXEL = 3;

    function Torch() {
      this.GamePads = this.Enum("Pad1", "Pad2", "Pad3", "Pad4");
      this.AjaxData = this.Enum("DOMString", "ArrayBuffer", "Blob", "Document", "Json", "Text");
      this.AjaxLoader = AjaxLoader;
      this.Event = Event;
      this.EventDispatcher = EventDispatcher;
      this.Trashable = Trashable;
    }

    Torch.prototype.Needs = function(key) {
      if (!Torch[key]) {
        throw "Compenent " + key + " is required";
      }
      return this;
    };

    Torch.prototype.FatalError = function(error) {
      var errorHtml, stack;
      if (this.fatal) {
        return;
      }
      this.fatal = true;
      if (typeof error === "string") {
        error = new Error(error);
      }
      document.body.backgroundColor = "black";
      stack = error.stack.replace(/\n/g, "<br><br>");
      errorHtml = "<code style='color:#C9302C;margin-left:15%;font-size:24px'>" + error + "</code>\n<br>\n<code style='color:#C9302C;font-size:20px;font-weight:bold'>Stack Trace:</code><br>\n<code style='color:#C9302C;font-size:20px'>" + stack + "</code><br>";
      document.body.innerHTML = errorHtml;
      throw error;
    };

    Torch.prototype.StrictErrors = function() {
      return this.STRICT_ERRORS = true;
    };

    Torch.prototype.Enum = function() {
      var i, j, len, obj, part, parts;
      parts = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      obj = {};
      for (i = j = 0, len = parts.length; j < len; i = ++j) {
        part = parts[i];
        obj[part] = i + 1;
      }
      return obj;
    };

    Torch.prototype.ExtendProperties = function() {
      var Class, func, j, keyProp, len, prop, properties, results;
      Class = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      results = [];
      for (j = 0, len = properties.length; j < len; j++) {
        prop = properties[j];
        keyProp = prop.unCapitalize();
        func = function(arg) {
          if (arg === void 0) {
            return this[keyProp];
          }
          this[keyProp] = arg;
          return this;
        };
        results.push(Class.prototype[prop] = func);
      }
      return results;
    };

    return Torch;

  })();

  exports.Torch = new Torch();

}).call(this);
