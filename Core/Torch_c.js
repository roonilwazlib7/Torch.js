// Generated by CoffeeScript 1.10.0
(function() {
  var Body, HitBox, Point, Rectangle, Torch, Vector, exports,
    slice = [].slice;

  exports = this;

  Function.prototype.is = function(otherFunction) {
    var i, items, key, len, proto;
    proto = this.prototype;
    items = Object.create(otherFunction.prototype);
    for (i = 0, len = items.length; i < len; i++) {
      key = items[i];
      proto[key] = items[key];
    }
    return this;
  };

  Function.prototype.Make = function(game, x, y) {
    return new this(game, x, y);
  };

  String.prototype.format = function() {
    var args, replacer;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    replacer = function(match, number) {
      if (typeof args[number] !== void 0) {
        return args[number];
      }
      if (typeof args[number] === void 0) {
        return match;
      }
    };
    return this.replace(/{(\d+)}/g, replacer);
  };

  window.onerror = function() {
    var args, errorObj;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (!Torch.STRICT_ERRORS) {
      return;
    }
    errorObj = args[4];
    if (errorObj !== void 0) {
      return Torch.FatalError(errorObj);
    } else {
      return Torch.FatalError("An error has occured");
    }
  };

  Torch = {
    CANVAS: 1,
    WEBGL: 2,
    Message: function(message, color) {
      if ($("#torch_message").length > 0) {
        message = $("<p>" + message + "</p>");
        message.css("font-weight", "bold");
        if (color) {
          message.css("color", color);
        }
        return $("#torch_message").append(message);
      }
    },
    FatalError: function(error) {
      var stack;
      if (this.fatal) {
        return;
      }
      this.fatal = true;
      if (typeof error === "string") {
        error = new Error(error);
      }
      document.body.backgroundColor = "black";
      stack = error.stack.replace(/\n/g, "<br><br>");
      $("body").empty();
      $("body").prepend("<code style='color:#C9302C;font-size:20px'>" + stack + "</code><br>");
      $("body").prepend("<code style='color:#C9302C;margin-left:15%;font-size:24px'>" + error + "</code><br><code style='color:#C9302C;font-size:20px;font-weight:bold'>Stack Trace:</code><br>");
      throw error;
    },
    StrictErrors: function() {
      return this.STRICT_ERRORS = true;
    }
  };

  Rectangle = (function() {
    function Rectangle(x1, y1, width, height) {
      this.x = x1;
      this.y = y1;
      this.width = width;
      this.height = height;
      this.z = -10;
    }

    Rectangle.prototype.GetOffset = function(rectangle) {
      var halfHeights, halfWidths, offset, sharedXPlane, sharedYPlane, vx, vy;
      vx = (this.x + (this.width / 2)) - (rectangle.x + (rectangle.width / 2));
      vy = (this.y + (this.height / 2)) - (rectangle.y + (rectangle.height / 2));
      halfWidths = (this.width / 2) + (rectangle.width / 2);
      halfHeights = (this.height / 2) + (rectangle.height / 2);
      sharedXPlane = (this.x + this.width) - (rectangle.x + rectangle.width);
      sharedYPlane = (this.y + this.height) - (rectangle.y + rectangle.height);
      offset = {
        x: halfWidths - Math.abs(vx),
        y: halfHeights - Math.abs(vy),
        vx: vx,
        vy: vy,
        halfWidths: halfWidths,
        halfHeights: halfHeights,
        sharedXPlane: sharedXPlane,
        sharedYPlane: sharedYPlane
      };
      return offset;
    };

    Rectangle.prototype.Intersects = function(rectangle) {
      var a, b;
      a = this;
      b = rectangle;
      if (a.x < (b.x + b.width) && (a.x + a.width) > b.x && a.y < (b.y + b.height) && (a.y + a.height) > b.y) {
        return a.GetOffset(b);
      } else {
        return false;
      }
    };

    Rectangle.prototype.ShiftFrom = function(rectangle, transX, transY) {
      var x, y;
      x = null;
      y = null;
      if (transX === void 0) {
        x = rectangle.x;
      } else {
        x = rectangle.x + transX;
      }
      if (transY === void 0) {
        y = rectangle.y;
      } else {
        y = rectangle.y + transY;
      }
      this.x = x;
      return this.y = y;
    };

    return Rectangle;

  })();

  Vector = (function() {
    function Vector(x1, y1) {
      this.x = x1;
      this.y = y1;
    }

    Vector.prototype.Normalize = function() {
      var r, x, y;
      r = (this.x * this.x) + (this.y * this.y);
      r = Math.sqrt(r);
      x = this.x;
      y = this.y;
      this.x = x / r;
      return this.y = y / r;
    };

    Vector.prototype.GetDistance = function(otherVector) {
      var raw;
      raw = Math.pow(otherVector.x - this.x, 2) + Math.pow(otherVector.y - this.y, 2);
      return Math.sqrt(raw);
    };

    return Vector;

  })();

  Body = (function() {
    function Body() {
      var Plane;
      Plane = function() {
        this.velocity = 0;
        this.acceleration = 0;
        this.lv = 0;
        this.la = 0;
        this.aTime = 0;
        return this.maxVelocity = 100;
      };
      this.x = new Plane();
      this.y = new Plane();
    }

    Body.prototype.Velocity = function(plane, velocity) {
      this[plane].velocity = velocity;
      return this;
    };

    Body.prototype.Acceleration = function(plane, acceleration) {
      this[plane].acceleration = acceleration;
      return this;
    };

    return Body;

  })();

  HitBox = (function() {
    function HitBox() {
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
    }

    return HitBox;

  })();

  Point = (function() {
    function Point(x1, y1) {
      this.x = x1;
      this.y = y1;
    }

    return Point;

  })();

  Torch.GamePads = {
    Pad1: 0,
    Pad2: 1,
    Pad3: 2,
    Pad4: 3
  };

  Torch.Rectangle = Rectangle;

  Torch.Vector = Vector;

  Torch.Body = Body;

  Torch.HitBox = HitBox;

  Torch.Point = Point;

  exports.Torch = Torch;

}).call(this);
