// Generated by CoffeeScript 1.10.0

/*
    @class Torch.WebGLGame @extends Torch.CanvasGame
    @author roonilwazlib

    @constructor
        @param canvasId, string, REQUIRED
        @param width, number|string, REQUIRED
        @param height, number|string, REQUIRED
        @param name, string, REQUIRED
        @param graphicsType, enum, REQUIRED
        @param pixel, enum

    @description
        Torch.WebGLGame dictates that WEBGL, through three.js, be used to render
        graphics.
 */

(function() {
  var WebGLGame,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  WebGLGame = (function(superClass) {
    extend(WebGLGame, superClass);

    function WebGLGame(canvasId, width, height, name, graphicsType, pixel) {
      this.canvasId = canvasId;
      this.width = width;
      this.height = height;
      this.name = name;
      this.graphicsType = graphicsType;
      this.pixel = pixel != null ? pixel : 0;
      this.InitGame();
    }

    WebGLGame.prototype.InitGraphics = function() {
      this.gl_rendererContainer = document.getElementById(this.canvasId);
      this.gl_scene = new THREE.Scene();
      this.gl_camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 1000);
      this.gl_camera.position.z = 600;
      this.gl_renderer = new THREE.WebGLRenderer({
        antialias: this.pixel !== Torch.PIXEL
      });
      this.gl_renderer.setSize(window.innerWidth, window.innerHeight);
      this.gl_renderer.setPixelRatio(window.devicePixelRatio);
      this.canvasNode = this.gl_renderer.domElement;
      this.gl_rendererContainer.appendChild(this.canvasNode);
      return this.On("Resize", (function(_this) {
        return function(event) {
          _this.gl_renderer.setSize(_this.Viewport.width, _this.Viewport.height);
          _this.gl_camera.aspect = _this.Viewport.width / _this.Viewport.height;
          return _this.gl_camera.updateProjectionMatrix();
        };
      })(this));
    };

    WebGLGame.prototype.DrawSprites = function() {
      var i, len, ref, sprite;
      this.spriteList.sort(function(a, b) {
        return a.drawIndex - b.drawIndex;
      });
      ref = this.spriteList;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        if (sprite.draw && !sprite.trash && !sprite.GHOST_SPRITE) {
          sprite.Draw();
        }
        if (sprite.trash) {
          sprite.Three().Remove();
        }
      }
      this.gl_camera.lookAt(this.gl_scene.position);
      return this.gl_renderer.render(this.gl_scene, this.gl_camera);
    };

    WebGLGame.prototype.UpdateSprites = function() {
      var cleanedSprites, i, len, ref, sprite;
      cleanedSprites = [];
      ref = this.spriteList;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        if (!sprite.trash) {
          if (!sprite.game.paused) {
            sprite.Update();
          }
          cleanedSprites.push(sprite);
        } else {
          if (sprite.Three() !== void 0) {
            sprite.Three().Remove();
          }
          sprite.trashed = true;
          sprite.Emit("Trash");
        }
      }
      return this.spriteList = cleanedSprites;
    };

    WebGLGame.prototype.GetThreeTransformedPoint = function(point) {
      return new Torch.Point(point.x, point.y);
    };

    return WebGLGame;

  })(Torch.CanvasGame);

  Torch.WebGLGame = WebGLGame;

}).call(this);
