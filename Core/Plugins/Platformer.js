// Generated by CoffeeScript 1.11.1
(function() {
  var Actor, Block, Fluid, SpawnItem, Spawner, exports,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  exports = this;

  Torch.Platformer = {
    Gravity: 0.001,
    SHIFT_COLLIDE_LEFT: 5,
    SetWorld: function(spawnItems) {
      return Torch.Platformer.spawnItems = spawnItems;
    }
  };

  Actor = (function() {
    Actor.prototype.ACTOR = true;

    Actor.prototype.Health = 100;

    Actor.prototype.currentFriction = 1;

    Actor.prototype.inFluid = false;

    Actor.prototype.onGround = false;

    Actor.prototype.onLeft = false;

    Actor.prototype.onTop = false;

    Actor.prototype.onRight = false;

    Actor.prototype.hitLockCounter = 0;

    Actor.prototype.hitLockBlinkCounter = 0;

    Actor.prototype.hitLock = false;

    Actor.prototype.hitLockMax = 1000;

    function Actor() {
      throw "Actor is a base class";
    }

    Actor.prototype.HitLock = function() {
      return this.hitLock = true;
    };

    Actor.prototype.Hit = function(amount) {
      if (amount == null) {
        amount = 1;
      }
      this.Health -= amount;
      if (this.Health <= 0) {
        return this.Die;
      }
    };

    Actor.prototype.Die = function() {
      return this.isDead = true;
    };

    Actor.prototype.BlockCollision = function(item, offset) {
      if (offset) {
        if (offset.vx < offset.halfWidths && offset.vy < offset.halfHeights) {
          if (offset.x < offset.y) {
            this.Body.Velocity("y", 0);
            if (offset.vx > 0) {
              if (!item.Sprite.Slope) {
                this.Rectangle.x += offset.x + Torch.Platformer.SHIFT_COLLIDE_LEFT;
                this.Body.Velocity("x", 0);
                return this.onLeft = true;
              } else {
                return this.BlockSlope(item.Sprite, offset);
              }
            } else if (offset.vx < 0) {
              if (!item.Sprite.Slope) {
                this.Rectangle.x -= offset.x;
                this.Body.Velocity("x", 0);
                return this.onRight = true;
              } else {
                return this.BlockSlope(item.Sprite, offset);
              }
            }
          } else if (offset.x > offset.y) {
            if (offset.vy > 0) {
              this.Rectangle.y += offset.y;
              return this.Body.Velocity("y", 0);
            } else if (offset.vy < 0) {
              if (!item.Sprite.Slope) {
                this.Rectangle.y -= offset.y - item.Sprite.sink;
                this.Body.Acceleration("y", 0).Velocity("y", 0);
                this.onGround = true;
                if (!this.inFluid) {
                  return this.currentFriction = item.Sprite.friction;
                }
              } else {
                return this.BlockSlope(item.Sprite, offset);
              }
            }
          }
        }
      }
    };

    Actor.prototype.BlockSlope = function(block, offset) {
      var Yoffset;
      Yoffset = offset.x * Math.tan(block.Slope);
      this.Rectangle.y = block.Rectangle.y + (block.Rectangle.height - Yoffset) - this.Rectangle.height;
      return this.onSlope = true;
    };

    Actor.prototype.FluidCollision = function(item, offset) {
      if (offset) {
        this.currentFriction = item.Sprite.friction;
        this.Body.y.acceleration = item.Sprite.gravity;
        return this.inFluid = true;
      }
    };

    Actor.prototype.UpdateActor = function() {
      var i, item, len, offset, rect, ref;
      this.inFluid = false;
      this.onGround = false;
      this.onTop = false;
      this.onRight = false;
      this.onLeft = false;
      ref = Torch.Platformer.spawnItems;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        rect = this.Rectangle;
        if (item.spawned && item.Sprite && item.Sprite.BLOCK && this.NotSelf(item.Sprite) && this.ACTOR) {
          offset = this.Rectangle.Intersects(item.Sprite.Rectangle);
          this.BlockCollision(item, offset);
        }
        if (item.spawned && item.Sprite && item.Sprite.FLUID && this.NotSelf(item.Sprite) && this.ACTOR) {
          offset = this.Rectangle.Intersects(item.Sprite.Rectangle);
          this.FluidCollision(item, offset);
        }
        if (!this.onGround && !this.inFluid) {
          this.Body.y.acceleration = Torch.Platformer.Gravity;
        }
      }
      if (this.hitLock) {
        this.hitLockCounter += Game.deltaTime;
        this.hitLockBlinkCounter += Game.deltaTime;
        if (this.hitLockBlinkCounter >= 200) {
          if (this.opacity === 0.1) {
            this.opacity = 0.8;
          } else {
            this.opacity = 0.1;
          }
          this.hitLockBlinkCounter = 0;
        }
        if (this.hitLockCounter >= this.hitLockMax) {
          this.hitLock = false;
          this.opacity = 1;
          this.hitLockCounter = 0;
          return this.hitLockBlinkCounter = 0;
        }
      }
    };

    return Actor;

  })();

  Block = (function() {
    Block.prototype.BLOCK = true;

    Block.prototype.friction = 1;

    Block.prototype.sink = 0;

    function Block() {
      throw "Block is a base class";
    }

    return Block;

  })();

  Fluid = (function() {
    Fluid.prototype.FLUID = true;

    Fluid.prototype.friction = 0.3;

    Fluid.prototype.gravity = 0.0001;

    Fluid.prototype.drawIndex = 30;

    function Fluid() {
      throw "Fluid is a base class";
    }

    return Fluid;

  })();

  Spawner = (function(superClass) {
    extend(Spawner, superClass);

    function Spawner(spawnItems1) {
      this.spawnItems = spawnItems1;
      Torch.Platformer.SetWorld(this.spawnItems);
    }

    return Spawner;

  })(Torch.GhostSprite);

  ({
    FlushSprites: function() {
      var i, item, len, ref, results;
      ref = this.spawnItems;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.Sprite) {
          results.push(item.Sprite.Trash());
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    Update: function() {
      var i, item, len, newRec, ref, results, spr, viewRect;
      if (this.spawnItems.length > 0) {
        viewRect = Game.Viewport.GetViewRectangle();
        ref = this.spriteList;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          if (!item.Manual) {
            newRec = {
              x: item.Sprite.Rectangle.x,
              y: item.Sprite.Rectangle.y,
              width: item.Sprite.Rectangle.width,
              height: item.Sprite.Rectangle.height
            };
            if (!item.spawned && !item.dead && item.DisableDynamicSpawning) {
              spr = this.SpawnTypes[item.SpawnType](item.Position, item, item.addData);
              item.Sprite = spr;
              item.spawned = true;
              results.push(spr.spawnItem = item);
            } else if (!item.spawned && !item.dead && viewRect.Intersects({
              x: item.Position.x,
              y: item.Position.y,
              width: item.width * Game.SCALE,
              height: item.height * Game.SCALE
            })) {
              if (item.SpawnType) {
                spr = this.SpawnTypes[item.SpawnType](item.Position, item, item.addData);
                item.Sprite = spr;
                item.spawned = true;
                results.push(spr.spawnItem = item);
              } else {
                results.push(void 0);
              }
            } else if (item.spawned && item.Sprite && item.Sprite.Rectangle && !viewRect.Intersects(newRec)) {
              item.Sprite.Trash();
              item.Sprite = null;
              results.push(item.spawned = false);
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    }
  });

  SpawnItem = (function() {
    function SpawnItem(spawnType, spawned, obj, position) {
      this.spawnType = spawnType;
      this.spawned = spawned;
      this.obj = obj;
      this.position = position;
      if (this.obj) {
        this.Sprite = this.obj;
      }
    }

    return SpawnItem;

  })();

  exports.Facing = Torch.Enum("Right", "Left");

  exports.Walking = Torch.Enum("Right", "Left", "None");

  Torch.Platformer.Actor = Actor;

  Torch.Platformer.Block = Block;

  Torch.Platformer.Fluid = Fluid;

  Torch.Platformer.Spawner = Spawner;

  Torch.Platformer.spawnItem = SpawnItem;

}).call(this);
