// Generated by CoffeeScript 1.10.0

/*
    @class Torch.Sprite
    @author roonilwazlib

    @constructor
        @param game, Torch.Game, REQUIRED
        @param x, number, REQUIRED
        @param y, number, REQUIRED

    @description
        Torch.Sprite defines practically everything that can be in the game.
        Think anything that moves or performs any action, anything that you
        can see. Torch.Sprite is semi-abstract, it can be inherited or used on
        its own.
    @usage
        CoffeeScript:
            sprite = new Torch.Sprite(game, 0, 0)

        JavaScript:
            var sprite = new Torch.Sprite(game, 0, 0)
 */

(function() {
  var GhostSprite, Sprite,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Sprite = (function() {
    function Sprite(game, x, y) {
      this.InitSprite(game, x, y);
    }

    Sprite.MixIn(Torch.EventDispatcher).MixIn(Torch.Trashable);

    Sprite.prototype.InitSprite = function(game, x, y) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (game === null || game === void 0) {
        Torch.FatalError("Unable to initialize sprite without game");
      }
      this.InitEventDispatch();
      this.game = game;
      this.GL = this.game.graphicsType === Torch.WEBGL;
      this.Bind = new Torch.Bind(this);
      this.Collisions = new Torch.CollisionManager(this);
      this.Rectangle = new Torch.Rectangle(x, y, 0, 0);
      this.Body = new Torch.Body();
      this.HitBox = new Torch.HitBox();
      this.position = new Torch.Point(x, y);
      this.DrawTexture = null;
      this.TexturePack = null;
      this.TextureSheet = null;
      this.mouseOver = false;
      this.clickTrigger = false;
      this.clickAwayTrigger = false;
      this.draw = true;
      this.wasClicked = false;
      this.fixed = false;
      this.drawIndex = 0;
      this.rotation = 0;
      this.opacity = 1;
      this._torch_add = "Sprite";
      this._torch_uid = "";
      this.events = {};
      this.tasks = {};
      this.children = [];
      this.stateMachines = [];
      if (!this.GL) {
        this.renderer = new CanvasRenderer(this);
      }
      return game.Add(this);
    };

    Sprite.prototype.Fixed = function(tog) {
      if (tog !== void 0) {
        if (this.fixed) {
          this.fixed = false;
        } else {
          this.fixed = true;
        }
      } else {
        this.fixed = tog;
      }
      return this;
    };

    Sprite.prototype.UpdateSprite = function() {
      this.UpdateBody();
      this.UpdateEvents();
      this.UpdateGLEntities();
      this.UpdateHitBox();
      this.Rectangle.x = this.position.x;
      this.Rectangle.y = this.position.y;
      return this.Collisions.Update();
    };

    Sprite.prototype.UpdateEvents = function() {
      var mouseRec, reComputedMouseRec;
      if (!this.game.Mouse.GetRectangle(this.game).Intersects(this.Rectangle) && this.mouseOver) {
        this.mouseOver = false;
        this.Emit("MouseLeave", new Torch.Event(this.game, {
          sprite: this
        }));
      }
      if (this.game.Mouse.GetRectangle(this.game).Intersects(this.Rectangle)) {
        if (!this.mouseOver) {
          this.Emit("MouseOver", new Torch.Event(this.game, {
            sprite: this
          }));
        }
        this.mouseOver = true;
      } else if (this.fixed) {
        mouseRec = this.game.Mouse.GetRectangle();
        reComputedMouseRec = new Torch.Rectangle(mouseRec.x, mouseRec.y, mouseRec.width, mouseRec.height);
        reComputedMouseRec.x += this.game.Viewport.x;
        reComputedMouseRec.y += this.game.Viewport.y;
        if (reComputedMouseRec.Intersects(this.Rectangle)) {
          this.mouseOver = true;
        } else {
          this.mouseOver = false;
        }
      } else {
        this.mouseOver = false;
      }
      if (this.mouseOver && this.game.Mouse.down && !this.clickTrigger) {
        this.clickTrigger = true;
      }
      if (this.clickTrigger && !this.game.Mouse.down && this.mouseOver) {
        this.wasClicked = true;
        this.Emit("Click", new Torch.Event(this.game, {
          sprite: this
        }));
        this.clickTrigger = false;
      }
      if (this.clickTrigger && !this.game.Mouse.down && !this.mouseOver) {
        this.clickTrigger = false;
      }
      if (!this.game.Mouse.down && !this.mouseOver && this.clickAwayTrigger) {
        this.Emit("ClickAway", new Torch.Event(this.game, {
          sprite: this
        }));
        this.wasClicked = false;
        this.clickAwayTrigger = false;
      } else if (this.clickTrigger && !this.game.Mouse.down && this.mouseOver) {
        this.clickAwayTrigger = false;
      } else if (this.game.Mouse.down && !this.mouseOver) {
        this.clickAwayTrigger = true;
      }
      if (!this.Rectangle.Intersects(this.game.BoundRec)) {
        return this.Emit("OutOfBounds", new Torch.Event(this.game, {
          sprite: this
        }));
      }
    };

    Sprite.prototype.UpdateBody = function() {
      var deltaTime, dir, ref, velX, velY;
      velX = this.Body.x.velocity;
      velY = this.Body.y.velocity;
      deltaTime = this.game.deltaTime;
      if (this.Body.x.acceleration !== this.Body.x.la) {
        this.Body.x.la = this.Body.x.acceleration;
        this.Body.x.aTime = 0;
      }
      if (this.Body.x.acceleration !== 0) {
        this.Body.x.aTime += deltaTime;
        velX += this.Body.x.aTime * this.Body.x.acceleration;
      }
      if (this.Body.y.acceleration !== this.Body.y.la) {
        this.Body.y.la = this.Body.y.acceleration;
        this.Body.y.aTime = 0;
      }
      if (this.Body.y.acceleration !== 0) {
        this.Body.y.aTime += deltaTime;
        velY += this.Body.y.aTime * this.Body.y.acceleration;
      }
      if (Math.abs(velX) < Math.abs(this.Body.x.maxVelocity)) {
        this.position.x += velX * deltaTime;
      } else {
        dir = (ref = velX < 0) != null ? ref : -{
          1: 1
        };
        this.position.x += dir * this.Body.x.maxVelocity * deltaTime;
      }
      return this.position.y += velY * deltaTime;
    };

    Sprite.prototype.UpdateGLEntities = function() {
      var transform;
      if (!this.GL) {
        return;
      }
      transform = this.GetThreeTransform();
      if (this.GL && this.gl_three_sprite) {
        return this.Three().Position("x", transform.x).Position("y", transform.y).Position("z", this.Rectangle.z).Rotation(this.rotation).DrawIndex(this.drawIndex).Opacity(this.opacity).Width(this.Width()).Height(this.Height());
      }
    };

    Sprite.prototype.UpdateHitBox = function() {
      var shiftX, shiftY;
      shiftX = this.Rectangle.width / 8;
      shiftY = this.Rectangle.height / 8;
      return this.HitBox = {
        x: this.Rectangle.x + shiftX,
        y: this.Rectangle.y + shiftY,
        width: this.Rectangle.width - (2 * shiftX),
        height: this.Rectangle.height - (2 * shiftY)
      };
    };

    Sprite.prototype.Update = function() {
      return this.UpdateSprite();
    };

    Sprite.prototype.GetCurrentDraw = function() {
      if (this.TexturePack) {
        return this.TexturePackAnimation.GetCurrentFrame();
      } else if (this.TextureSheet) {
        return this.TextureSheetAnimation.GetCurrentFrame();
      } else if (this.DrawTexture) {
        return this.DrawTexture;
      }
    };

    Sprite.prototype.Draw = function() {
      if (this.renderer !== null) {
        return this.renderer.Draw();
      }
    };

    Sprite.prototype.Hide = function() {
      this.draw = false;
      return this;
    };

    Sprite.prototype.Show = function() {
      this.draw = true;
      return this;
    };

    Sprite.prototype.Clone = function(x, y) {
      var proto;
      proto = this.constructor;
      return new proto(this.game, x, y);
    };

    Sprite.prototype.NotSelf = function(otherSprite) {
      return otherSprite._torch_uid !== this._torch_uid;
    };

    Sprite.prototype.Velocity = function(plane, optionalArgument) {
      if (optionalArgument === null || optionalArgument === void 0) {
        return this.Body.Velocity(plane);
      } else {
        if (typeof optionalArgument !== "number") {
          this.game.FatalError("Cannot set velocity. Expected number, got: " + (typeof optionalArgument));
        }
        this.Body.Velocity(plane, optionalArgument);
        return this;
      }
    };

    Sprite.prototype.Position = function(plane, optionalArgument) {
      if (optionalArgument === null || optionalArgument === void 0) {
        return this.position[plane];
      } else {
        if (typeof optionalArgument !== "number") {
          this.game.FatalError("Cannot set position. Expected number, got: " + (typeof optionalArgument));
        }
        this.position[plane] = optionalArgument;
        this.Rectangle[plane] = optionalArgument;
        return this;
      }
    };

    Sprite.prototype.Width = function(optionalArgument) {
      var scale;
      if (optionalArgument === null || optionalArgument === void 0) {
        return this.Rectangle.width;
      } else {
        if (typeof optionalArgument !== "number") {
          this.game.FatalError("Cannot set width. Expected number, got: " + (typeof optionalArgument));
          if (this.GL) {
            scale = optionalArgument / this.gl_orig_width;
            this.gl_scene_object.scale.x = scale;
          }
        }
        this.Rectangle.width = optionalArgument;
        return this;
      }
    };

    Sprite.prototype.Height = function(optionalArgument) {
      if (optionalArgument === null || optionalArgument === void 0) {
        return this.Rectangle.height;
      } else {
        if (typeof optionalArgument !== "number") {
          this.game.FatalError("Cannot set height. Expected number, got: " + (typeof optionalArgument));
        }
        this.Rectangle.height = optionalArgument;
        return this;
      }
    };

    Sprite.prototype.Three = function() {
      if (!this.GL) {
        throw "Unable to access three.js object";
      }
      return this.gl_three_sprite;
    };

    Sprite.prototype.Move = function(plane, argument) {
      if (typeof argument !== "number") {
        this.game.FatalError("Cannot move position. Expected number, got: " + (typeof argument));
      }
      this.Position(plane, this.Position(plane) + argument);
      return this;
    };

    Sprite.prototype.Rotation = function(rotation) {
      if (rotation === void 0) {
        return this.rotation;
      } else {
        if (typeof rotation !== "number") {
          this.game.FatalError("Rotation values must be a number. Provided was '" + (typeof rotation) + "'");
        }
        this.rotation = rotation;
        return this;
      }
    };

    Sprite.prototype.Opacity = function(opacity) {
      if (opacity === void 0) {
        return this.opacity;
      } else {
        if (typeof opacity !== "number") {
          this.game.FatalError("Opacity values must be a number. Provided was '" + (typeof opacity) + "'");
        }
        this.opacity = opacity;
        return this;
      }
    };

    Sprite.prototype.DrawIndex = function(drawIndex) {
      if (drawIndex === void 0) {
        return this.drawIndex;
      } else {
        if (typeof drawIndex !== "number") {
          this.game.FatalError("DrawIndex values must be a number. Provided was '" + (typeof drawIndex) + "'");
        }
        this.drawIndex = drawIndex;
        return this;
      }
    };

    Sprite.prototype.Scale = function(scale) {
      if (scale === void 0) {
        return this.scale;
      } else {
        return this.scale = scale;
      }
    };

    Sprite.prototype.GetDirectionVector = function(otherSprite) {
      var vec;
      vec = new Torch.Vector(otherSprite.Rectangle.x - this.Rectangle.x, otherSprite.Rectangle.y - this.Rectangle.y);
      vec.Normalize();
      return vec;
    };

    Sprite.prototype.GetDistance = function(otherSprite) {
      var otherVec, thisVec;
      thisVec = new Torch.Vector(this.Rectangle.x, this.Rectangle.y);
      otherVec = new Torch.Vector(otherSprite.Rectangle.x, otherSprite.Rectangle.y);
      return thisVec.GetDistance(otherVec);
    };

    Sprite.prototype.GetAngle = function(otherSprite) {
      var angle, directionVector;
      directionVector = this.GetDirectionVector(otherSprite);
      angle = Math.atan2(directionVector.y, directionVector.x);
      return angle + (Math.PI + (Math.PI / 2));
    };

    Sprite.prototype.Center = function() {
      var width, x;
      width = this.game.canvasNode.width;
      x = (width / 2) - (this.Rectangle.width / 2);
      this.Position("x", x);
      return this;
    };

    Sprite.prototype.CenterVertical = function() {
      var height, y;
      height = this.game.canvasNode.height;
      y = (height / 2) - (this.Rectangle.height / 2);
      this.Position("y", y);
      return this;
    };

    Sprite.prototype.CollidesWith = function(otherSprite) {
      return new Torch.Collider.CollisionDetector(this, otherSprite);
    };

    Sprite.prototype.Attatch = function(otherItem) {
      this.children.push(otherItem);
      return this.game.Add(otherItem);
    };

    Sprite.prototype.GetThreeTransform = function() {
      var point;
      point = this.game.GetThreeTransform(this.Position("x") + this.Width() / 2, this.Position("y") + this.Height() / 2);
      point.x -= this.Width() / 4;
      return point;
    };

    return Sprite;

  })();


  /*
      @class Torch.GhostSprite @extends Torch.Sprite
      @author roonilwazlib
  
      @abstract
  
      @description
          DEPRECATED. Use Torch.Task instead
          Used to create an 'invisible' sprite, i.e a sprite that is
          updated and not drawn.
   */

  GhostSprite = (function(superClass) {
    extend(GhostSprite, superClass);

    function GhostSprite() {
      return GhostSprite.__super__.constructor.apply(this, arguments);
    }

    GhostSprite.prototype.GHOST_SPRITE = true;

    return GhostSprite;

  })(Sprite);

  Torch.Sprite = Sprite;

  Torch.GhostSprite = GhostSprite;

}).call(this);
