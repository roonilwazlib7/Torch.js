// Generated by CoffeeScript 1.10.0
(function() {
  var CollisionManager;

  Torch.Collision = {
    AABB: 1,
    Circle: 2,
    SAT: 3
  };

  CollisionManager = (function() {
    CollisionManager.prototype.mode = Torch.Collision.AABB;

    CollisionManager.prototype.sprite = null;

    CollisionManager.prototype.filter = null;

    CollisionManager.prototype.limit = null;

    CollisionManager.prototype.enabled = false;

    function CollisionManager(sprite1) {
      this.sprite = sprite1;
      this.filter = {};
      this.game = this.sprite.game;
    }

    CollisionManager.prototype.Monitor = function() {
      return this.enabled = true;
    };

    CollisionManager.prototype.NotFiltered = function(sprite) {
      var key, ref, ref1, value;
      ref = this.game.filter;
      for (key in ref) {
        value = ref[key];
        if (key === "__type__") {
          if (value.constructor.name === sprite.constructor.name) {
            return false;
          }
        } else {
          if (value === sprite[key]) {
            return false;
          }
        }
      }
      ref1 = this.filter;
      for (key in ref1) {
        value = ref1[key];
        if (key === "__type__") {
          if (value.constructor.name === sprite.constructor.name) {
            return false;
          }
        } else {
          if (value === sprite[key]) {
            return false;
          }
        }
      }
      return true;
    };

    CollisionManager.prototype.InLimit = function(sprite) {
      var key, ref, value;
      ref = this.limit;
      for (key in ref) {
        value = ref[key];
        if (key === "__type__") {
          if (value.constructor.name === sprite.constructor.name) {
            return true;
          }
        } else {
          if (value === sprite[key]) {
            return true;
          }
        }
      }
      return false;
    };

    CollisionManager.prototype.Valid = function(sprite) {
      if (this.limit !== null) {
        return this.InLimit(sprite);
      }
      return this.NotFiltered(sprite);
    };

    CollisionManager.prototype.Filter = function(_filter) {
      return this.filter = _filter;
    };

    CollisionManager.prototype.Limit = function(_limit) {
      return this.limit = _limit;
    };

    CollisionManager.prototype.Mode = function(_mode) {
      var mode;
      return mode = _mode;
    };

    CollisionManager.prototype.Update = function() {
      var anyCollisions, collisionData, collisionDetected, i, len, otherSprite, ref;
      if (!this.sprite.game || !this.enabled) {
        return;
      }
      this.game = this.sprite.game;
      anyCollisions = false;
      ref = this.game.spriteList;
      for (i = 0, len = ref.length; i < len; i++) {
        otherSprite = ref[i];
        if (this.sprite.NotSelf(otherSprite) && this.Valid(otherSprite)) {
          collisionDetected = false;
          collisionData = {};
          switch (this.mode) {
            case Torch.Collision.AABB:
              collisionData = this.sprite.CollidesWith(otherSprite).AABB();
              collisionDetected = collisionData !== false;
          }
          if (collisionDetected) {
            collisionData.self = this.sprite;
            collisionData.collider = otherSprite;
            anyCollisions === true;
            this.sprite.Emit("Collision", new Torch.Event(this.game, {
              collisionData: collisionData
            }));
          }
        }
      }
      return this.sprite.Emit("NoCollision", new Torch.Event(this.game, {}));
    };

    CollisionManager.prototype.SimpleCollisionHandle = function(event, sink) {
      var offset, touching;
      if (sink == null) {
        sink = 1;
      }
      offset = event.collisionData;
      touching = {
        left: false,
        right: false,
        top: false,
        bottom: false
      };
      if (offset.vx < offset.halfWidths && offset.vy < offset.halfHeights) {
        if (offset.x < offset.y) {
          if (offset.vx > 0) {
            event.collisionData.self.position.x += offset.x * sink;
            touching.left = true;
          } else if (offset.vx < 0) {
            event.collisionData.self.position.x -= offset.x * sink;
            touching.right = true;
          }
        } else if (offset.x > offset.y) {
          if (offset.vy > 0) {
            event.collisionData.self.position.y += offset.y * sink;
            touching.top = true;
          } else if (offset.vy < 0) {
            event.collisionData.self.position.y -= offset.y * sink;
            touching.bottom = true;
          }
        }
      }
      return touching;
    };

    return CollisionManager;

  })();

  Torch.CollisionManager = CollisionManager;

}).call(this);
