// Generated by CoffeeScript 1.10.0
(function() {
  var slice = [].slice;

  Function.prototype.MixIn = Function.prototype.is = function(otherFunction) {
    var items, key, proto, value;
    proto = this.prototype;
    items = Object.create(otherFunction.prototype);
    for (key in items) {
      value = items[key];
      proto[key] = value;
    }
    return this;
  };

  String.prototype.format = function() {
    var args, replacer;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    replacer = function(match, number) {
      if (typeof args[number] !== void 0) {
        return args[number];
      }
      if (typeof args[number] === void 0) {
        return match;
      }
    };
    return this.replace(/{(\d+)}/g, replacer);
  };

  String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  String.prototype.unCapitalize = function() {
    return this.charAt(0).toLowerCase() + this.slice(1);
  };

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var EventDispatcher, exports;

  exports = this;

  EventDispatcher = (function() {
    function EventDispatcher() {}

    EventDispatcher.dispatchers = [];

    EventDispatcher.prototype.InitEventDispatch = function() {
      this.events = {};
      return EventDispatcher.dispatchers.push(this);
    };

    EventDispatcher.prototype.On = function(eventName, eventHandle) {
      var eventNest;
      if (!this.events[eventName]) {
        eventNest = [];
        eventNest.triggers = 0;
        this.events[eventName] = eventNest;
      }
      this.events[eventName].push(eventHandle);
      return this;
    };

    EventDispatcher.prototype.Emit = function(eventName, eventArgs) {
      var ev, i, len, ref;
      if (this.events[eventName] !== void 0) {
        ref = this.events[eventName];
        for (i = 0, len = ref.length; i < len; i++) {
          ev = ref[i];
          this.events[eventName].triggers++;
          ev(eventArgs);
        }
      }
      return this;
    };

    EventDispatcher.prototype.Off = function(eventName) {
      var key, ref, val;
      if (eventName == null) {
        eventName = "";
      }
      if (eventName !== "") {
        this.events[eventName] = void 0;
      } else {
        ref = this.events;
        for (key in ref) {
          val = ref[key];
          this.events[key] = void 0;
        }
      }
      return this;
    };

    return EventDispatcher;

  })();

  exports.EventDispatcher = EventDispatcher;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Trashable, exports;

  exports = this;

  Trashable = (function() {
    function Trashable() {}

    Trashable.prototype.trash = false;

    Trashable.prototype.Trash = function() {
      this.trash = true;
      return this;
    };

    return Trashable;

  })();

  exports.Trashable = Trashable;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var AjaxLoader, Event, Task, Torch, exports,
    slice = [].slice;

  exports = this;

  window.onerror = function() {
    var args, errorObj;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (!window.Torch.STRICT_ERRORS) {
      return;
    }
    errorObj = args[4];
    if (errorObj !== void 0) {
      return window.Torch.FatalError(errorObj);
    } else {
      return window.Torch.FatalError("An error has occured");
    }
  };

  Task = (function() {
    Task.MixIn(Trashable);

    Task.prototype._torch_add = "Task";

    function Task(func1) {
      this.func = func1;
    }

    Task.prototype.Execute = function(game) {
      return this.func(game);
    };

    return Task;

  })();

  AjaxLoader = (function() {
    AjaxLoader.prototype.onFinish = function() {};

    AjaxLoader.prototype.onError = function() {};

    function AjaxLoader(url, responseType) {
      if (responseType == null) {
        responseType = window.Torch.AjaxData.Text;
      }
      this.url = url;
      this.responseType = this.GetResponseTypeString(responseType);
    }

    AjaxLoader.prototype.GetResponseTypeString = function(responseType) {
      switch (responseType) {
        case window.Torch.AjaxData.DOMString:
          return "";
        case window.Torch.AjaxData.ArrayBuffer:
          return "arraybuffer";
        case window.Torch.AjaxData.Blob:
          return "blob";
        case window.Torch.AjaxData.Document:
          return "document";
        case window.Torch.AjaxData.Json:
          return "json";
        case window.Torch.AjaxData.Text:
          return "text";
      }
    };

    AjaxLoader.prototype.Error = function(func) {
      return this.onError = func;
    };

    AjaxLoader.prototype.Finish = function(func) {
      return this.onFinish = func;
    };

    AjaxLoader.prototype.Load = function() {
      var request;
      request = new XMLHttpRequest();
      request.open('GET', this.url, true);
      request.responseType = this.responseType;
      request.onload = (function(_this) {
        return function() {
          return _this.onFinish(request.response, _this);
        };
      })(this);
      return request.send();
    };

    return AjaxLoader;

  })();

  Event = (function() {
    function Event(game1, data) {
      var key, ref, value;
      this.game = game1;
      this.data = data;
      if (this.game !== null) {
        this.time = this.game.time;
      }
      ref = this.data;
      for (key in ref) {
        value = ref[key];
        this[key] = value;
      }
    }

    return Event;

  })();

  Torch = (function() {
    var Is;

    Torch.prototype.CANVAS = 1;

    Torch.prototype.WEBGL = 2;

    Torch.prototype.PIXEL = 3;

    function Torch() {
      this.GamePads = this.Enum("Pad1", "Pad2", "Pad3", "Pad4");
      this.AjaxData = this.Enum("DOMString", "ArrayBuffer", "Blob", "Document", "Json", "Text");
      this.Types = this.Enum("String", "Number", "Object", "Array", "Function", "Sprite", "Game", "Null");
      this.AjaxLoader = AjaxLoader;
      this.Event = Event;
      this.EventDispatcher = EventDispatcher;
      this.Trashable = Trashable;
    }

    Torch.prototype.RandomInRange = function(min, max) {
      return Math.random() * (max - min + 1) + min;
    };

    Torch.prototype.Needs = function(key) {
      if (!Torch[key]) {
        throw "Compenent " + key + " is required";
      }
      return this;
    };

    Torch.prototype.FatalError = function(error) {
      var errorHtml, stack;
      if (this.fatal) {
        return;
      }
      this.fatal = true;
      if (typeof error === "string") {
        error = new Error(error);
      }
      document.body.backgroundColor = "black";
      stack = error.stack.replace(/\n/g, "<br><br>");
      errorHtml = "<code style='color:#C9302C;margin-left:15%;font-size:24px'>" + error + "</code>\n<br>\n<code style='color:#C9302C;font-size:20px;font-weight:bold'>Stack Trace:</code><br>\n<code style='color:#C9302C;font-size:20px'>" + stack + "</code><br>";
      document.body.innerHTML = errorHtml;
      throw error;
    };

    Torch.prototype.StrictErrors = function() {
      return this.STRICT_ERRORS = true;
    };

    Torch.prototype.DisableConsoleWarnings = function() {
      return console.warn = function() {};
    };

    Torch.prototype.Enum = function() {
      var i, j, len, obj, part, parts;
      parts = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      obj = {};
      for (i = j = 0, len = parts.length; j < len; i = ++j) {
        part = parts[i];
        obj[part] = i + 1;
      }
      return obj;
    };

    Torch.prototype.Assert = function(expression, errorTag) {
      if (errorTag == null) {
        errorTag = "Assertation Failed";
      }
      if (!expression) {
        return Torch.FatalError(errorTag);
      }
    };

    Torch.prototype.TypeOf = function(obj) {
      var objTypes, typeString;
      objTypes = [];
      if (obj.__torch__ !== void 0) {
        objTypes.push(obj.__torch__);
      }
      typeString = {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
      switch (typeString) {
        case "string":
          objTypes.push(Torch.Types.String);
          break;
        case "number":
          objTypes.push(Torch.Types.Number);
          break;
        case "object":
          objTypes.push(Torch.Types.Object);
          break;
        case "array":
          objTypes.push(Torch.Types.Array);
          break;
        case "function":
          objTypes.push(Torch.Types.Function);
          break;
        default:
          objTypes.push(Torch.Types.Null);
      }
      return objTypes;
    };

    Is = function(obj, torchType) {
      return Torch.TypeOf(obj).indexOf(torchType) !== -1;
    };

    Torch.prototype.ExtendProperties = function() {
      var Class, func, j, keyProp, len, prop, properties, results;
      Class = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      results = [];
      for (j = 0, len = properties.length; j < len; j++) {
        prop = properties[j];
        keyProp = prop.unCapitalize();
        func = function(arg) {
          if (arg === void 0) {
            return this[keyProp];
          }
          this[keyProp] = arg;
          return this;
        };
        results.push(Class.prototype[prop] = func);
      }
      return results;
    };

    return Torch;

  })();

  exports.Torch = new Torch();

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var DebugConsole,
    slice = [].slice;

  DebugConsole = (function() {
    DebugConsole.prototype.enabled = false;

    DebugConsole.prototype.console = null;

    DebugConsole.prototype.consoleInput = null;

    DebugConsole.prototype.consoleOutput = null;

    DebugConsole.prototype.commands = null;

    DebugConsole.prototype.variables = null;

    function DebugConsole(game) {
      var div, html;
      this.game = game;
      html = "<div id = \"torch-console\" style = \"position: absolute;z-index: 100;top:0;border: 1px solid orange;background-color:black\">\n    <p style = \"color:white;margin-left:1%;font-family:monospace\">Torch Dev Console. Type /HELP for usage</p>\n    <input type=\"text\" id = \"torch-console-input\" placeholder=\"Torch Dev Console, type /HELP for usage\"/ style = \"outline: none;border: none;font-family: monospace;color: white;background-color: black;font-size: 16px;padding: 3%;width: 100%;\" />\n    <div id = \"torch-console-output\" style = \"overflow:auto;outline: none;border: none;font-family: monospace;color: white;background-color: black;font-size: 14px;padding: 1%;width: 98%;height:250px\"></div>\n</div>";
      div = document.createElement("div");
      div.innerHTML = html;
      div.style.display = "none";
      document.body.appendChild(div);
      this.console = div;
      this.consoleInput = document.getElementById("torch-console-input");
      this.consoleOutput = document.getElementById("torch-console-output");
      this.commands = {};
      this.variables = {};
      this.LoadDefaultCommands();
      document.addEventListener("keypress", (function(_this) {
        return function(e) {
          if (e.keyCode === 47) {
            return _this.Toggle(true);
          } else if (e.keyCode === 13) {
            return _this.ParseCommand();
          }
        };
      })(this));
      document.addEventListener("keydown", (function(_this) {
        return function(e) {
          if (e.keyCode === 27) {
            return _this.Toggle(false);
          }
        };
      })(this));
    }

    DebugConsole.prototype.Toggle = function(tog) {
      if (tog == null) {
        tog = true;
      }
      if (tog) {
        this.console.style.display = "block";
        this.consoleInput.focus();
        return this.enabled = true;
      } else {
        this.console.style.display = "none";
        this.consoleInput.value = "";
        return this.enabled = false;
      }
    };

    DebugConsole.prototype.Output = function(content, color) {
      if (color == null) {
        color = "white";
      }
      content = content.replace(/\n/g, "<br>");
      return this.consoleOutput.innerHTML += "<p style='color:orange'>TorchDev$</p><p style='color:" + color + "'>" + content + "</p>";
    };

    DebugConsole.prototype.ParseCommand = function() {
      var args, command, commandText, i, index, len, option, ref;
      if (!this.enabled) {
        return;
      }
      commandText = this.consoleInput.value;
      commandText = commandText.replace(/\$(.*?)\$/g, (function(_this) {
        return function(text) {
          var clippedText;
          clippedText = text.substring(1, text.length - 1);
          return _this.variables[clippedText];
        };
      })(this));
      command = commandText.split(" ")[0].split("/")[1];
      args = [];
      ref = commandText.split(" ");
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        option = ref[index];
        if (index !== 0) {
          args.push(option);
        }
      }
      return this.ExecuteCommand(command, args);
    };

    DebugConsole.prototype.ExecuteCommand = function(command, args) {
      var ref;
      if (!this.commands[command]) {
        this.Output("Command '" + command + "' does not exist.", "red");
      } else {
        return (ref = this.commands)[command].apply(ref, [this].concat(slice.call(args)));
      }
    };

    DebugConsole.prototype.AddCommand = function(name, callback) {
      return this.commands[name] = callback;
    };

    DebugConsole.prototype.LoadDefaultCommands = function() {
      this.AddCommand("HELP", (function(_this) {
        return function(tConsole) {
          return tConsole.Output("type '/HELP' for help\ntype '/FPS' for frame rate\ntype '/TIME' for game time\ntype '/E [statement]' to execute a JavaScript statement\ntype '/RUN [path] to load and execute a JavaScript file'");
        };
      })(this));
      this.AddCommand("CLEAR", (function(_this) {
        return function(tConsole) {
          return _this.consoleOutput.innerHTML = "";
        };
      })(this));
      this.AddCommand("FPS", (function(_this) {
        return function(tConsole) {
          return tConsole.Output("Current FPS: " + _this.game.fps + "\nAverage FPS: " + 0.);
        };
      })(this));
      this.AddCommand("TIME", (function(_this) {
        return function(tConsole) {
          return tConsole.Output("Total Game Time: " + _this.game.time + "\nDelta Time: " + _this.game.deltaTime);
        };
      })(this));
      this.AddCommand("RUN", (function(_this) {
        return function(tConsole, filePath) {
          var loader;
          loader = new Torch.AjaxLoader(filePath, Torch.AjaxData.Text);
          loader.Finish(function(data) {
            var error, error1;
            try {
              eval(data);
              return tConsole.Output("File Executed", "green");
            } catch (error1) {
              error = error1;
              return tConsole.Output("File: '" + statement + "' caused an error. " + error, "red");
            }
          });
          return loader.Load();
        };
      })(this));
      this.AddCommand("SET", (function(_this) {
        return function(tConsole, name, value) {
          if (isNaN(value)) {
            _this.variables[name] = value;
          } else {
            _this.variables[name] = parseFloat(value);
          }
          return _this.Output("Set " + name + " to " + value, "green");
        };
      })(this));
      return this.AddCommand("E", (function(_this) {
        return function(tConsole, statement) {
          var error, error1;
          try {
            eval(statement);
            return tConsole.Output("Statment Executed", "green");
          } catch (error1) {
            error = error1;
            return tConsole.Output("Statement: '" + statement + "' caused an error. " + error, "red");
          }
        };
      })(this));
    };

    return DebugConsole;

  })();

  Torch.DebugConsole = DebugConsole;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var BodyManager;

  BodyManager = (function() {
    function BodyManager(sprite) {
      this.sprite = sprite;
      Torch.Assert(this.sprite !== null && this.sprite.__torch__ === Torch.Types.Sprite);
      this.game = this.sprite.game;
      this.velocity = new Torch.Vector(0, 0);
      this.acceleration = new Torch.Vector(0, 0);
      this.omega = 0;
      this.alpha = 0;
    }

    BodyManager.prototype.Update = function() {
      this.sprite.position.x += this.velocity.x * this.game.Loop.updateDelta;
      this.sprite.position.y += this.velocity.y * this.game.Loop.updateDelta;
      this.velocity.x += this.acceleration.x * this.game.Loop.updateDelta;
      this.velocity.y += this.acceleration.y * this.game.Loop.updateDelta;
      return this.sprite.rotation += this.omega * this.game.Loop.updateDelta;
    };

    BodyManager.prototype.Debug = function(turnOn) {
      if (turnOn == null) {
        turnOn = true;
      }
      return this.DEBUG = turnOn;
    };

    BodyManager.prototype.AngleTo = function(otherSprite) {
      var directionVector;
      directionVector = this.DirectionTo(otherSprite);
      return directionVector.angle;
    };

    BodyManager.prototype.DistanceTo = function(otherSprite) {
      var otherVec, thisVec;
      thisVec = new Torch.Vector(this.sprite.position.x, this.sprite.position.y);
      otherVec = new Torch.Vector(otherSprite.position.x, otherSprite.position.y);
      otherVec.SubtractVector(thisVec);
      return otherVec.magnitude;
    };

    BodyManager.prototype.DirectionTo = function(otherSprite) {
      var vec;
      vec = new Torch.Vector(otherSprite.position.x - this.sprite.position.x, otherSprite.position.y - this.sprite.position.y);
      vec.Normalize();
      return vec;
    };

    return BodyManager;

  })();

  Torch.Body = BodyManager;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var SizeManager;

  SizeManager = (function() {
    SizeManager.prototype.width = 0;

    SizeManager.prototype.height = 0;

    SizeManager.prototype.scale = null;

    function SizeManager(sprite) {
      var rect;
      this.sprite = sprite;
      rect = this.sprite.rectangle;
      this.width = rect.width;
      this.height = rect.height;
      this.scale = {
        width: 1,
        height: 1
      };
    }

    SizeManager.prototype.Update = function() {
      var rect;
      rect = this.sprite.rectangle;
      rect.width = this.width * this.scale.width;
      return rect.height = this.height * this.scale.height;
    };

    SizeManager.prototype.Set = function(width, height) {
      this.width = width;
      return this.height = height;
    };

    SizeManager.prototype.Scale = function(widthScale, heightScale) {
      this.scale.width = widthScale;
      return this.scale.height = heightScale;
    };

    return SizeManager;

  })();

  Torch.SizeManager = SizeManager;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var EventManager;

  EventManager = (function() {
    EventManager.prototype.mouseOver = false;

    EventManager.prototype.clickTrigger = false;

    EventManager.prototype.clickAwayTrigger = false;

    EventManager.prototype.draw = true;

    EventManager.prototype.wasClicked = false;

    function EventManager(sprite) {
      this.sprite = sprite;
      this.game = this.sprite.game;
    }

    EventManager.prototype.Update = function() {
      var mouseRec, reComputedMouseRec;
      if (!this.game.Mouse.GetRectangle().Intersects(this.sprite.rectangle) && this.mouseOver) {
        this.mouseOver = false;
        this.sprite.Emit("MouseLeave", new Torch.Event(this.game, {
          sprite: this.sprite
        }));
      }
      if (this.game.Mouse.GetRectangle(this.game).Intersects(this.sprite.rectangle)) {
        if (!this.mouseOver) {
          this.sprite.Emit("MouseOver", new Torch.Event(this.game, {
            sprite: this.sprite
          }));
        }
        this.mouseOver = true;
      } else if (this.sprite.fixed) {
        mouseRec = this.game.Mouse.GetRectangle();
        reComputedMouseRec = new Torch.Rectangle(mouseRec.x, mouseRec.y, mouseRec.width, mouseRec.height);
        reComputedMouseRec.x += this.game.Viewport.x;
        reComputedMouseRec.y += this.game.Viewport.y;
        if (reComputedMouseRec.Intersects(this.sprite.rectangle)) {
          this.mouseOver = true;
        } else {
          this.mouseOver = false;
        }
      } else {
        this.mouseOver = false;
      }
      if (this.mouseOver && this.game.Mouse.down && !this.clickTrigger) {
        this.clickTrigger = true;
      }
      if (this.clickTrigger && !this.game.Mouse.down && this.mouseOver) {
        this.wasClicked = true;
        this.sprite.Emit("Click", new Torch.Event(this.game, {
          sprite: this.sprite
        }));
        this.clickTrigger = false;
      }
      if (this.clickTrigger && !this.game.Mouse.down && !this.mouseOver) {
        this.clickTrigger = false;
      }
      if (!this.game.Mouse.down && !this.mouseOver && this.clickAwayTrigger) {
        this.sprite.Emit("ClickAway", new Torch.Event(this.game, {
          sprite: this.sprite
        }));
        this.wasClicked = false;
        this.clickAwayTrigger = false;
      } else if (this.clickTrigger && !this.game.Mouse.down && this.mouseOver) {
        this.clickAwayTrigger = false;
      } else if (this.game.Mouse.down && !this.mouseOver) {
        this.clickAwayTrigger = true;
      }
      if (!this.sprite.rectangle.Intersects(this.game.BoundRec)) {
        return this.sprite.Emit("OutOfBounds", new Torch.Event(this.game, {
          sprite: this.sprite
        }));
      }
    };

    return EventManager;

  })();

  Torch.EventManager = EventManager;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var EffectManager;

  EffectManager = (function() {
    EffectManager.prototype.tint = null;

    EffectManager.prototype.mask = null;

    function EffectManager(sprite) {
      this.sprite = sprite;
      this.tint = {
        color: null,
        opacity: 0.5
      };
      this.mask = {
        texture: null,
        "in": false,
        out: false
      };
    }

    return EffectManager;

  })();

  Torch.EffectManager = EffectManager;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var StateMachineManager;

  StateMachineManager = (function() {
    function StateMachineManager(sprite) {
      this.sprite = sprite;
      this.stateMachines = {};
    }

    StateMachineManager.prototype.CreateStateMachine = function(name) {
      this.stateMachines[name] = new Torch.StateMachine(this.sprite);
      return this.stateMachines[name];
    };

    StateMachineManager.prototype.GetStateMachine = function(name) {
      return this.stateMachines[name];
    };

    StateMachineManager.prototype.Update = function() {
      var key, ref, results, sm;
      ref = this.stateMachines;
      results = [];
      for (key in ref) {
        sm = ref[key];
        results.push(sm.Update());
      }
      return results;
    };

    return StateMachineManager;

  })();

  Torch.StateMachineManager = StateMachineManager;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var GridManager,
    slice = [].slice;

  GridManager = (function() {
    GridManager.prototype.parent = null;

    GridManager.prototype.children = null;

    GridManager.prototype.centered = false;

    GridManager.prototype.centerVertical = false;

    GridManager.prototype.alignLeft = false;

    GridManager.prototype.alignRight = false;

    GridManager.prototype.alignTop = false;

    GridManager.prototype.alignBottom = false;

    function GridManager(sprite1) {
      this.sprite = sprite1;
      this.position = new Torch.Point(0, 0);
      this.children = [];
    }

    GridManager.prototype.Align = function() {
      var i, len, positionTags, results, tag;
      positionTags = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (i = 0, len = positionTags.length; i < len; i++) {
        tag = positionTags[i];
        switch (tag) {
          case "left":
            results.push(this.alignLeft = true);
            break;
          case "right":
            results.push(this.alignRight = true);
            break;
          case "top":
            results.push(this.alignTop = true);
            break;
          case "bottom":
            results.push(this.alignBottom = true);
            break;
          default:
            results.push(void 0);
        }
      }
      return results;
    };

    GridManager.prototype.Center = function(turnOn) {
      if (turnOn == null) {
        turnOn = true;
      }
      return this.centered = turnOn;
    };

    GridManager.prototype.CenterVertical = function(turnOn) {
      if (turnOn == null) {
        turnOn = true;
      }
      return this.centerVertical = turnOn;
    };

    GridManager.prototype.Append = function(sprite) {
      sprite.Grid.parent = this.sprite;
      sprite.drawIndex = this.sprite.drawIndex + 1;
      return sprite.fixed = this.sprite.fixed;
    };

    GridManager.prototype.Parent = function() {
      return this.parent;
    };

    GridManager.prototype.Children = function(matcher) {
      var child, children, i, key, len, matching, ref, value;
      if (!matcher) {
        return this.children;
      }
      children = [];
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        matching = true;
        for (key in matcher) {
          value = matcher[key];
          if (!child[key] === value) {
            matching = false;
          }
        }
        if (matching) {
          children.append(child);
        }
      }
      return children;
    };

    GridManager.prototype.Ancestors = function(matcher) {
      var ancestor, ancestors, key, matched, results, value;
      if (!this.parent) {
        return null;
      }
      ancestors = [];
      ancestor = this.parent;
      results = [];
      while (ancestor.Parent() !== null) {
        if (!matcher) {
          ancestors.push(ancestor);
        } else {
          matched = true;
          for (key in matcher) {
            value = matcher[key];
            if (ancestor[key] !== value) {
              matched = false;
            }
          }
          if (matched) {
            ancestors.push(ancestor);
          }
        }
        results.push(ancestor = ancestor.Parent());
      }
      return results;
    };

    GridManager.prototype.ApplyCentering = function(point) {
      if (this.centered) {
        point.x = (point.x + this.parent.rectangle.width / 2) - (this.sprite.rectangle.width / 2);
      }
      if (this.centerVertical) {
        point.y = (point.y + this.parent.rectangle.height / 2) - (this.sprite.rectangle.height / 2);
      }
      return point;
    };

    GridManager.prototype.ApplyAlignment = function(point) {
      if (this.alignLeft) {
        point.x = 0;
      }
      if (this.alignRight) {
        point.x = point.x + (this.parent.rectangle.width - this.sprite.rectangle.width);
      }
      if (this.alignTop) {
        point.y = 0;
      }
      if (this.alignBottom) {
        point.y = point.y + (this.parent.rectangle.height - this.sprite.rectangle.height);
      }
      return point;
    };

    GridManager.prototype.ResolveAbosolutePosition = function() {
      var basePoint;
      if (this.parent === null) {
        return this.sprite.position;
      }
      basePoint = this.parent.position.Clone();
      basePoint = this.ApplyCentering(basePoint);
      basePoint = this.ApplyAlignment(basePoint);
      basePoint.Apply(this.position);
      return basePoint;
    };

    GridManager.prototype.Update = function() {
      this.sprite.position = this.ResolveAbosolutePosition();
      if (this.parent !== null) {
        this.sprite.drawIndex = this.parent.drawIndex + 1;
        return this.sprite.fixed = this.parent.fixed;
      }
    };

    return GridManager;

  })();

  Torch.GridManager = GridManager;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var GhostSprite, Sprite,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Sprite = (function() {
    Sprite.MixIn(Torch.EventDispatcher).MixIn(Torch.Trashable);

    Sprite.prototype.__torch__ = Torch.Types.Sprite;

    function Sprite(game, x, y) {
      this.InitSprite(game, x, y);
    }

    Sprite.prototype.InitSprite = function(game, x, y) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (game === null || game === void 0) {
        Torch.FatalError("Unable to initialize sprite without game");
      }
      this.InitEventDispatch();
      this.game = game;
      this.rectangle = new Torch.Rectangle(x, y, 0, 0);
      this.position = new Torch.Point(x, y);
      this.Bind = new Torch.Bind(this);
      this.Collisions = new Torch.CollisionManager(this);
      this.Body = new Torch.Body(this);
      this.Size = new Torch.SizeManager(this);
      this.Events = new Torch.EventManager(this);
      this.Effects = new Torch.EffectManager(this);
      this.States = new Torch.StateMachineManager(this);
      this.Grid = new Torch.GridManager(this);
      this.DrawTexture = null;
      this.TexturePack = null;
      this.TextureSheet = null;
      this.TextureSimple = null;
      this.fixed = false;
      this.draw = true;
      this.drawIndex = 0;
      this.rotation = 0;
      this.opacity = 1;
      this._torch_add = "Sprite";
      this._torch_uid = "";
      this.events = {};
      this.renderer = new CanvasRenderer(this);
      return game.Add(this);
    };

    Sprite.prototype.UpdateSprite = function() {
      this.Body.Update();
      this.Size.Update();
      this.Events.Update();
      this.States.Update();
      this.Grid.Update();
      this.rectangle.x = this.position.x;
      this.rectangle.y = this.position.y;
      return this.Collisions.Update();
    };

    Sprite.prototype.Update = function() {
      return this.UpdateSprite();
    };

    Sprite.prototype.Draw = function() {
      return this.renderer.Draw();
    };

    Sprite.prototype.GetCurrentDraw = function() {
      if (this.TexturePack) {
        return this.TexturePackAnimation.GetCurrentFrame();
      } else if (this.TextureSheet) {
        return this.TextureSheetAnimation.GetCurrentFrame();
      } else if (this.DrawTexture) {
        return this.DrawTexture;
      }
    };

    Sprite.prototype.Clone = function() {
      var args, proto;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      proto = this.constructor;
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(proto, args, function(){});
    };

    Sprite.prototype.NotSelf = function(otherSprite) {
      return otherSprite._torch_uid !== this._torch_uid;
    };

    Sprite.prototype.Center = function() {
      var width, x;
      width = this.game.canvasNode.width;
      x = (width / 2) - (this.rectangle.width / 2);
      this.position.x = x;
      return this;
    };

    Sprite.prototype.CenterVertical = function() {
      var height, y;
      height = this.game.canvasNode.height;
      y = (height / 2) - (this.rectangle.height / 2);
      this.position.y = y;
      return this;
    };

    Sprite.prototype.CollidesWith = function(otherSprite) {
      return new Torch.Collider.CollisionDetector(this, otherSprite);
    };

    return Sprite;

  })();


  /*
  gonna kill this...
   */

  GhostSprite = (function(superClass) {
    extend(GhostSprite, superClass);

    function GhostSprite() {
      return GhostSprite.__super__.constructor.apply(this, arguments);
    }

    GhostSprite.prototype.GHOST_SPRITE = true;

    return GhostSprite;

  })(Sprite);

  Torch.Sprite = Sprite;

  Torch.GhostSprite = GhostSprite;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Text, measureCanvas,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  measureCanvas = document.createElement("CANVAS");

  measureCanvas.width = 500;

  measureCanvas.height = 500;

  Text = (function(superClass) {
    extend(Text, superClass);

    Text.prototype.TEXT = true;

    Text.measureCanvas = measureCanvas.getContext("2d");

    function Text(game, x, y, data) {
      this.InitText(game, x, y, data);
    }

    Text.prototype.InitText = function(game, x, y, data) {
      this.InitSprite(game, x, y);
      this.data = data;
      this.font = "Arial";
      this.fontSize = 16;
      this.fontWeight = "";
      this.color = "#2b4531";
      this.text = "";
      this.lastText = "";
      this.width = 100;
      this.height = 100;
      this.Size.scale = {
        width: 1,
        height: 1
      };
      return this.Init();
    };

    Text.prototype.Init = function() {
      if (this.data.font) {
        this.font = this.data.font;
      }
      if (this.data.fontSize) {
        this.fontSize = this.data.fontSize;
      }
      if (this.data.fontWeight) {
        this.fontWeight = this.data.fontWeight;
      }
      if (this.data.color) {
        this.color = this.data.color;
      }
      if (this.data.text) {
        this.text = this.data.text;
      }
      if (this.data.rectangle) {
        this.rectangle = this.data.rectangle;
      }
      if (this.data.buffHeight) {
        this.buffHeight = this.data.buffHeight;
      }
      return this.Render();
    };

    Text.prototype.Render = function() {
      var canvas, cnv, image;
      cnv = document.createElement("CANVAS");
      Text.measureCanvas.font = this.fontSize + "px " + this.font;
      cnv.width = Torch.Text.measureCanvas.measureText(this.text).width;
      cnv.height = this.fontSize;
      if (this.buffHeight) {
        cnv.height += this.buffHeight;
      }
      canvas = cnv.getContext("2d");
      canvas.fillStyle = this.color;
      canvas.font = this.fontWeight + " " + this.fontSize + "px " + this.font;
      canvas.fillText(this.text, 0, cnv.height);
      image = new Image();
      image.src = cnv.toDataURL();
      image.onload = (function(_this) {
        return function() {
          if (_this.GL) {
            if (_this.Three()) {
              _this.Three().Remove();
            }
            return _this.Bind.WebGLTexture({
              gl_2d_canvas_generated_image: true,
              width: image.width,
              height: image.height,
              texture: new THREE.TextureLoader().load(image.src)
            });
          } else {
            return _this.Bind.Texture(image);
          }
        };
      })(this);
      this.rectangle.width = cnv.width;
      return this.rectangle.height = this.fontSize;
    };

    Text.prototype.Update = function() {
      Text.__super__.Update.call(this);
      return this.UpdateText();
    };

    Text.prototype.UpdateText = function() {
      if (this.text !== this.lastText) {
        this.Render();
        return this.lastText = this.text;
      }
    };

    return Text;

  })(Torch.Sprite);

  Torch.ExtendProperties(Text, "Text", "Font", "FontSize", "FontWeight", "Color");

  Torch.Text = Text;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var SpriteGroup,
    slice = [].slice;

  SpriteGroup = (function() {
    function SpriteGroup(sprites1, game) {
      var i, len, ref, sprite;
      this.sprites = sprites1 != null ? sprites1 : [];
      this.game = game;
      ref = this.sprites;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        sprite.anchorX = sprite.Rectangle.x;
      }
      return this;
    }

    SpriteGroup.prototype.Factory = function(spriteClass) {
      this.spriteFactory = spriteClass;
      return this;
    };

    SpriteGroup.prototype.Add = function() {
      var args, newSprite, sprites, x, y;
      sprites = arguments[0], x = arguments[1], y = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
      if (sprites === null || sprites === void 0 && this.spriteFactory !== void 0) {
        newSprite = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(this.spriteFactory, [this.game, x, y].concat(slice.call(args)), function(){});
        this.sprites.push(newSprite);
        return newSprite;
      } else {
        this.sprites = this.sprites.concat(sprites);
      }
      return this;
    };

    SpriteGroup.prototype.Trash = function() {
      var i, len, ref, sprite;
      ref = this.sprites;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        sprite.Trash();
      }
      return this;
    };

    SpriteGroup.prototype.Shift = function(transition) {
      var i, len, ref, results, sprite;
      ref = this.sprites;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        if (transition.x) {
          results.push(sprite.Rectangle.x = sprite.anchorX + transition.x);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    SpriteGroup.prototype.Hide = function() {
      var i, len, ref, sprite;
      ref = this.sprites;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        sprite.draw = false;
      }
      return this;
    };

    SpriteGroup.prototype.Show = function() {
      var i, len, ref, sprite;
      ref = this.sprites;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        sprite.draw = true;
      }
      return this;
    };

    SpriteGroup.prototype.Center = function() {
      var i, len, ref, sprite;
      ref = this.sprites;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        sprite.Center();
      }
      return this;
    };

    SpriteGroup.prototype.ToggleFixed = function() {
      var i, len, ref, sprite;
      ref = this.sprites;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        sprite.ToggleFixed();
      }
      return this;
    };

    return SpriteGroup;

  })();

  Torch.SpriteGroup = SpriteGroup;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var SpriteGrid;

  SpriteGrid = (function() {
    function SpriteGrid(game, gridXml) {
      this.game = game;
      this.gridXml = gridXml;
      this.ParseXml();
    }

    SpriteGrid.prototype.ParseXml = function() {
      var parser, root, sprites, xmlDoc;
      parser = new DOMParser();
      xmlDoc = parser.parseFromString(this.gridXml, "text/xml");
      root = xmlDoc.getElementsByTagName("SpriteGrid")[0];
      if (root === null) {
        this.game.FatalError("Unable to parse SpriteGrid XML, no SpriteGrid tag");
      }
      return sprites = root.getElementsByTagName("Sprite");
    };

    return SpriteGrid;

  })();

  Torch.SpriteGrid = SpriteGrid;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var CollisionDetector;

  Torch.Collider = {};

  CollisionDetector = (function() {
    function CollisionDetector(sprite, otherSprite) {
      this.sprite = sprite;
      this.otherSprite = otherSprite;
    }

    CollisionDetector.prototype.AABB = function() {
      return new Torch.Collider.AABB(this.sprite, this.otherSprite).Execute();
    };

    CollisionDetector.prototype.Circle = function() {
      return new Torch.Collider.Circle(this.sprite, this.otherSprite).Execute();
    };

    CollisionDetector.prototype.SAT = function() {
      return new Torch.Collider.SAT(this.sprite, this.otherSprite).Execute();
    };

    return CollisionDetector;

  })();

  Torch.Collider.CollisionDetector = CollisionDetector;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var AABB;

  AABB = (function() {
    function AABB(sprite, otherSprite) {
      this.sprite = sprite;
      this.otherSprite = otherSprite;
    }

    AABB.prototype.Execute = function() {
      return this.sprite.rectangle.Intersects(this.otherSprite.rectangle);
    };

    return AABB;

  })();

  Torch.Collider.AABB = AABB;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Circle;

  Circle = (function() {
    function Circle(sprite, otherSprite) {
      this.sprite = sprite;
      this.otherSprite = otherSprite;
    }

    Circle.prototype.Execute = function() {
      var circle1, circle2, distance, dx, dy;
      circle1 = {
        radius: this.sprite.Width(),
        x: this.sprite.Position("x"),
        y: this.sprite.Position("y")
      };
      circle2 = {
        radius: this.otherSprite.Width(),
        x: this.otherSprite.Position("x"),
        y: this.otherSprite.Position("y")
      };
      dx = circle1.x - circle2.x;
      dy = circle1.y - circle2.y;
      distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < circle1.radius + circle2.radius) {
        return true;
      }
      return false;
    };

    return Circle;

  })();

  Torch.Collider.Circle = Circle;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {


}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var CollisionManager;

  Torch.Collision = {
    AABB: 1,
    Circle: 2,
    SAT: 3
  };

  CollisionManager = (function() {
    CollisionManager.prototype.mode = Torch.Collision.AABB;

    CollisionManager.prototype.sprite = null;

    CollisionManager.prototype.filter = null;

    CollisionManager.prototype.limit = null;

    CollisionManager.prototype.enabled = false;

    function CollisionManager(sprite1) {
      this.sprite = sprite1;
      this.filter = {};
      this.game = this.sprite.game;
    }

    CollisionManager.prototype.Monitor = function() {
      return this.enabled = true;
    };

    CollisionManager.prototype.NotFiltered = function(sprite) {
      var key, ref, ref1, value;
      ref = this.game.filter;
      for (key in ref) {
        value = ref[key];
        if (key === "__type__") {
          if (value.constructor.name === sprite.constructor.name) {
            return false;
          }
        } else {
          if (value === sprite[key]) {
            return false;
          }
        }
      }
      ref1 = this.filter;
      for (key in ref1) {
        value = ref1[key];
        if (key === "__type__") {
          if (value.constructor.name === sprite.constructor.name) {
            return false;
          }
        } else {
          if (value === sprite[key]) {
            return false;
          }
        }
      }
      return true;
    };

    CollisionManager.prototype.InLimit = function(sprite) {
      var key, ref, value;
      ref = this.limit;
      for (key in ref) {
        value = ref[key];
        if (key === "__type__") {
          if (value.constructor.name === sprite.constructor.name) {
            return true;
          }
        } else {
          if (value === sprite[key]) {
            return true;
          }
        }
      }
      return false;
    };

    CollisionManager.prototype.Valid = function(sprite) {
      if (this.limit !== null) {
        return this.InLimit(sprite);
      }
      return this.NotFiltered(sprite);
    };

    CollisionManager.prototype.Filter = function(_filter) {
      return this.filter = _filter;
    };

    CollisionManager.prototype.Limit = function(_limit) {
      return this.limit = _limit;
    };

    CollisionManager.prototype.Mode = function(_mode) {
      var mode;
      return mode = _mode;
    };

    CollisionManager.prototype.Update = function() {
      var anyCollisions, collisionData, collisionDetected, i, len, otherSprite, ref;
      if (!this.sprite.game || !this.enabled) {
        return;
      }
      this.game = this.sprite.game;
      anyCollisions = false;
      ref = this.game.spriteList;
      for (i = 0, len = ref.length; i < len; i++) {
        otherSprite = ref[i];
        if (this.sprite.NotSelf(otherSprite) && this.Valid(otherSprite)) {
          collisionDetected = false;
          collisionData = {};
          switch (this.mode) {
            case Torch.Collision.AABB:
              collisionData = this.sprite.CollidesWith(otherSprite).AABB();
              collisionDetected = collisionData !== false;
          }
          if (collisionDetected) {
            collisionData.self = this.sprite;
            collisionData.collider = otherSprite;
            anyCollisions === true;
            this.sprite.Emit("Collision", new Torch.Event(this.game, {
              collisionData: collisionData
            }));
          }
        }
      }
      return this.sprite.Emit("NoCollision", new Torch.Event(this.game, {}));
    };

    CollisionManager.prototype.SimpleCollisionHandle = function(event, sink) {
      var offset, touching;
      if (sink == null) {
        sink = 1;
      }
      offset = event.collisionData;
      touching = {
        left: false,
        right: false,
        top: false,
        bottom: false
      };
      if (offset.vx < offset.halfWidths && offset.vy < offset.halfHeights) {
        if (offset.x < offset.y) {
          if (offset.vx > 0) {
            event.collisionData.self.position.x += offset.x * sink;
            touching.left = true;
          } else if (offset.vx < 0) {
            event.collisionData.self.position.x -= offset.x * sink;
            touching.right = true;
          }
        } else if (offset.x > offset.y) {
          if (offset.vy > 0) {
            event.collisionData.self.position.y += offset.y * sink;
            touching.top = true;
          } else if (offset.vy < 0) {
            event.collisionData.self.position.y -= offset.y * sink;
            touching.bottom = true;
          }
        }
      }
      return touching;
    };

    return CollisionManager;

  })();

  Torch.CollisionManager = CollisionManager;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Loop;

  Loop = (function() {
    function Loop(game) {
      this.game = game;
      this.fps = 50;
      this.frameTime = 1000 / this.fps;
      this.lag = 0;
      this.updateDelta = 0;
      this.drawDelta = 0;
      this.lagOffset;
    }

    Loop.prototype.Update = function() {
      this.game.update(this);
      this.game.Camera.Update();
      this.game.Timer.Update();
      this.game.Debug.Update();
      this.game.Tweens.Update();
      this.game.UpdateAnimations();
      this.game.UpdateTimeInfo();
      this.game.UpdateTasks();
      this.game.UpdateGamePads();
      return this.game.UpdateSprites();
    };

    Loop.prototype.Draw = function() {
      this.game.draw(this);
      return this.game.DrawSprites();
    };

    Loop.prototype.AdvanceFrame = function(timestamp) {
      var elapsed;
      if (this.game.time === void 0) {
        this.game.time = timestamp;
      }
      this.game.deltaTime = Math.round(timestamp - this.game.time);
      this.game.time = timestamp;
      elapsed = this.game.deltaTime;
      this.drawDelta = elapsed;
      this.updateDelta = this.frameTime;
      if (elapsed > 1000) {
        elapsed = this.frameTime;
      }
      this.lag += elapsed;
      while (this.lag >= this.frameTime) {
        this.Update();
        this.lag -= this.frameTime;
      }
      this.lagOffset = this.lag / this.frameTime;
      this.Draw();
      return window.requestAnimationFrame((function(_this) {
        return function(timestamp) {
          return _this.AdvanceFrame(timestamp);
        };
      })(this));
    };

    Loop.prototype.Run = function(timestamp) {
      return this.AdvanceFrame(0);
    };

    return Loop;

  })();

  Torch.Loop = Loop;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Load;

  Load = (function() {
    function Load(game) {
      this.game = game;
      this.game.Assets = {
        game: this.game,
        GetTexture: function(id) {
          return this.game.Assets.Textures[id];
        },
        GetTexturePack: function(id) {
          return this.game.Assets.TexturePacks[id];
        },
        GetTextureSheet: function(id) {
          return this.game.Assets.TextureSheets[id];
        },
        GetSound: function(id) {
          return this.game.Assets.Sounds[id].audio;
        }
      };
      this.game.Files = {};
      this.textures = this.game.Assets.Textures = [];
      this.texturePacks = this.game.Assets.TexturePacks = [];
      this.textureSheets = this.game.Assets.TextureSheets = [];
      this.sound = this.game.Assets.Sounds = [];
      this.audio = this.game.Assets.Audio = [];
      this.Stack = [];
      this.finish_stack = 0;
      this.progress = 0;
      this.loaded = false;
      this.loadLog = "";
    }

    Load.prototype.Sound = function(path, id) {
      if (this.sound[id]) {
        Torch.Error("Asset ID '" + id + "' already exists");
      }
      this.Stack.push({
        _torch_asset: "sound",
        id: id,
        path: path
      });
      return this.finish_stack++;
    };

    Load.prototype.Audio = function(path, id) {
      if (this.audio[id]) {
        Torch.Error("Asset ID '" + id + "' already exists");
      }
      this.Stack.push({
        _torch_asset: "audio",
        id: id,
        path: path
      });
      return this.finish_stack++;
    };

    Load.prototype.Texture = function(path, id) {
      var i, k, len, p, results;
      if (typeof path === "string") {
        this.Stack.push({
          _torch_asset: "texture",
          id: id,
          path: path
        });
        return this.finish_stack++;
      } else {
        results = [];
        for (i = k = 0, len = path.length; k < len; i = ++k) {
          p = path[i];
          results.push(this.Texture(path[i][0], path[i][1]));
        }
        return results;
      }
    };

    Load.prototype.PixlTexture = function(pattern, pallette, id) {
      var imSrc;
      imSrc = pixl(pattern, pallette).src;
      return this.Stack.push({
        _torch_asset: "texture",
        id: id,
        path: imSrc
      });
    };

    Load.prototype.TexturePack = function(path, id, range, fileType) {
      var i, pack, packId, packPath;
      pack = [];
      i = 1;
      while (i <= range) {
        packPath = path + "_" + i.toString() + "." + fileType;
        packId = id + "_" + i.toString();
        this.Stack.push({
          _torch_asset: "texture",
          id: packId,
          path: packPath
        });
        pack.push(packId);
        this.finish_stack++;
        i++;
      }
      return this.texturePacks[id] = pack;
    };

    Load.prototype.TextureSheet = function(path, id, totalWidth, totalHeight, clipWidth, clipHeight) {
      var columns, i, j, rows, sheet, sheetClip;
      totalWidth += clipWidth;
      rows = totalHeight / clipHeight;
      columns = totalWidth / clipWidth;
      sheet = [];
      this.Stack.push({
        _torch_asset: "texture",
        id: id,
        path: path
      });
      i = j = 0;
      while (i < columns) {
        while (j < rows) {
          sheetClip = {
            clipX: i * clipWidth,
            clipY: j * clipHeight,
            clipWidth: clipWidth,
            clipHeight: clipHeight
          };
          sheet.push(sheetClip);
          j++;
        }
        i++;
      }
      return this.textureSheets[id] = sheet;
    };

    Load.prototype.File = function(path, id) {
      console.log(id);
      this.finish_stack++;
      return this.Stack.push({
        _torch_asset: "file",
        id: id,
        path: path
      });
    };

    Load.prototype.LoadItemFinished = function() {
      var timeToLoad;
      this.finish_stack--;
      this.progress = (this.totalLoad - this.finish_stack) / this.totalLoad;
      this.game.Emit("LoadProgressed", new Torch.Event(this.game, {
        progress: this.progress
      }));
      if (this.finish_stack <= 0) {
        document.getElementsByClassName("font-loader")[0].remove();
        this.loadFinished();
        timeToLoad = (new Date().getTime() - this.startTime) / 1000;
        return console.log("%c" + this.game.name + " loaded in " + timeToLoad + "s", "background-color:green; color:white; padding:2px;padding-right:5px;padding-left:5px");
      }
    };

    Load.prototype.Load = function(finishFunction) {
      var aud, e, error, im, k, len, loader, ref, results, stackItem;
      this.loadFinished = finishFunction;
      this.totalLoad = this.finish_stack;
      this.startTime = new Date().getTime();
      try {
        ref = this.Stack;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          stackItem = ref[k];
          switch (stackItem._torch_asset) {
            case "texture":
              im = new Image();
              im.src = stackItem.path;
              stackItem.image = im;
              this.textures[stackItem.id] = stackItem;
              im.refId = stackItem.id;
              im.stackItem = stackItem;
              im.loader = this;
              results.push(im.onload = function() {
                this.loader.textures[this.stackItem.id].width = this.width;
                this.loader.textures[this.stackItem.id].height = this.height;
                return this.loader.LoadItemFinished();
              });
              break;
            case "sound":
              aud = new Audio();
              aud.src = stackItem.path;
              stackItem.audio = aud;
              this.sound[stackItem.id] = stackItem;
              this.LoadItemFinished();
              results.push(aud.toggle = function() {
                this.currentTime = 0;
                return this.play();
              });
              break;
            case "audio":
              loader = new Torch.AjaxLoader(this.audio[stackItem.id].url, Torch.AjaxData.ArrayBuffer);
              loader.Finish((function(_this) {
                return function(data) {
                  _this.audio[stackItem.id].encodedAudioData = data;
                  return _this.game.Audio.DecodeAudioData(data, function(buffer) {
                    _this.audio[stackItem.id].audioData = buffer;
                    return _this.LoadItemFinished();
                  });
                };
              })(this));
              results.push(loader.Load());
              break;
            case "file":
              if (!Torch.ELECTRON) {
                loader = new Torch.AjaxLoader(stackItem.path, Torch.AjaxData.Text);
                loader.stackItem = stackItem;
                loader.Finish((function(_this) {
                  return function(data, loader) {
                    _this.LoadItemFinished();
                    console.log(loader.stackItem.id);
                    return _this.game.Files[loader.stackItem.id] = data;
                  };
                })(this));
                results.push(loader.Load());
              } else {
                results.push(Torch.fs.readFile(stackItem.path, 'utf8', (function(_this) {
                  return function(er, data) {
                    _this.LoadItemFinished();
                    if (er) {
                      return _this.game.FatalError(new Error("Torch.Load.File file '{0}' could not be loaded".format(stackItem.path)));
                    } else {
                      return _this.game.Files[stackItem.id] = data;
                    }
                  };
                })(this)));
              }
              break;
            default:
              results.push(void 0);
          }
        }
        return results;
      } catch (error) {
        e = error;
        console.log("%c" + this.game.name + " could not load!", "background-color:" + Torch.Color.Ruby + "; color:white; padding:2px;padding-right:5px;padding-left:5px");
        return Torch.FatalError(e);
      }
    };

    return Load;

  })();

  Torch.Load = Load;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Viewport;

  Viewport = (function() {
    function Viewport(game) {
      this.game = game;
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.rotation = 0;
    }

    Viewport.prototype.GetViewRectangle = function() {
      return new Torch.Rectangle(-this.x, -this.y, this.width, this.height);
    };

    Viewport.prototype.HalfWidth = function() {
      return this.width / 2;
    };

    Viewport.prototype.HalfHeight = function() {
      return this.height / 2;
    };

    return Viewport;

  })();

  Torch.Viewport = Viewport;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var FutureEvent, Timer;

  Timer = (function() {
    function Timer(game) {
      this.game = game;
      this.futureEvents = [];
    }

    Timer.prototype.Update = function() {
      var event, i, len, ref, results;
      ref = this.futureEvents;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        event = ref[i];
        results.push(event.Update());
      }
      return results;
    };

    Timer.prototype.SetFutureEvent = function(timeToOccur, handle) {
      return this.futureEvents.push(new Torch.FutureEvent(timeToOccur, handle, this.game));
    };

    return Timer;

  })();

  FutureEvent = (function() {
    function FutureEvent(timeToOccur1, handle1, game) {
      this.timeToOccur = timeToOccur1;
      this.handle = handle1;
      this.game = game;
      this.time = 0;
    }

    FutureEvent.prototype.Update = function() {
      this.time += this.game.deltaTime;
      if (this.time >= this.timeToOccur) {
        if (this.handle !== null && this.handle !== void 0) {
          this.handle();
          return this.handle = null;
        }
      }
    };

    return FutureEvent;

  })();

  Torch.Timer = Timer;

  Torch.FutureEvent = FutureEvent;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Mouse;

  Mouse = (function() {
    function Mouse(game) {
      this.game = game;
      this.x = 0;
      this.y = 0;
      this.down = false;
    }

    Mouse.prototype.SetMousePos = function(c, evt) {
      var rect;
      rect = c.getBoundingClientRect();
      this.x = evt.clientX - rect.left;
      return this.y = evt.clientY - rect.top;
    };

    Mouse.prototype.GetRectangle = function() {
      return new Torch.Rectangle(this.x - this.game.Viewport.x, this.y - this.game.Viewport.y, 5, 5);
    };

    return Mouse;

  })();

  Torch.Mouse = Mouse;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Camera;

  Camera = (function() {
    Camera.prototype.position = null;

    function Camera(game) {
      this.game = game;
      this.position = new Torch.Point(0, 0);
    }

    Camera.prototype.Update = function() {};

    return Camera;

  })();

  Torch.Camera = Camera;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Layer, Layers;

  Layer = (function() {
    function Layer(drawIndex) {
      this.drawIndex = drawIndex;
      this.children = [];
      this.mapIndex - this.drawIndex;
    }

    Layer.prototype.DrawIndex = function(index) {
      var child, i, len, ref;
      if (!index) {
        return this.drawIndex;
      }
      this.drawIndex = index;
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        child.DrawIndex(index);
      }
      return this;
    };

    Layer.prototype.Add = function(child) {
      child.DrawIndex(this.index);
      return this.children.push(child);
    };

    return Layer;

  })();

  Layers = (function() {
    function Layers(game) {
      this.game = game;
      this.layers = [];
      this.layerMap = {};
    }

    Layers.prototype.Add = function(layerName) {
      var i, layer, len, name, results;
      layer = null;
      if (typeof layerName === "string") {
        layer = new Layer(this.layers.length);
        this.layerName[layerName] = layer;
        return this.layers.add(layer);
      } else {
        results = [];
        for (i = 0, len = layerName.length; i < len; i++) {
          name = layerName[i];
          layer = new Layer(this.layers.length);
          this.layerMap[name] = layer;
          results.push(this.layers.add(layer));
        }
        return results;
      }
    };

    Layers.prototype.Remove = function(layerName, tryToFill) {
      var cleanedLayers, i, index, item, l, layer, len, ref, results;
      if (!this.layerMap[layerName]) {
        return Torch.FatalError("Unable to remove layer '" + layerName + "'. Layer does not exist");
      } else {
        cleanedLayers = [];
        layer = layerMap[layerName];
        layer.Trash();
        delete this.layerMap[layerName];
        ref = this.layers;
        results = [];
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          item = ref[index];
          l = cleanedLayers[index];
          if (index !== layer.mapIndex) {
            cleanedLayers.push(l);
            if (tryToFill) {
              results.push(l.DrawIndex(l.DrawIndex() - 1));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    Layers.prototype.Get = function(layerName) {
      if (!this.layerMap[layerName]) {
        return Torch.FatalError("Unable to get layer '" + layerName + "'. Layer does not exist");
      } else {
        return this.layerMap[layerName];
      }
    };

    return Layers;

  })();

  Torch.Layers = Layers;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  Torch.Style = function() {
    var body, canvas;
    body = document.body;
    body.style.backgroundColor = "black";
    body.style.overflow = "hidden";
    canvas = document.getElementsByTagName("CANVAS")[0];
    canvas.style.border = "1px solid orange";
    return canvas.style.cursor = "pointer";
  };

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Debug;

  Debug = (function() {
    function Debug(game) {
      this.game = game;
      this.text = "";
      this.CreateHtmlDisplay();
    }

    Debug.prototype.CreateHtmlDisplay = function() {
      var display;
      display = document.createElement("DIV");
      display.style.position = "absolute";
      display.style.display = "block";
      display.style.color = "white";
      display.style.font = "monospace";
      display.style.top = 0;
      document.body.appendChild(display);
      return this.display = display;
    };

    Debug.prototype.Update = function() {};

    return Debug;

  })();

  Torch.Debug = Debug;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Key, Keys, exports;

  exports = this;

  Key = (function() {
    Key.MixIn(Torch.EventDispatcher);

    Key.prototype.down = false;

    function Key(keyCode) {
      this.keyCode = keyCode;
      this.InitEventDispatch();
    }

    return Key;

  })();

  Keys = (function() {
    Keys.MixIn(Torch.EventDispatcher);

    function Keys() {
      this.InitKeys();
    }

    Keys.prototype.InitKeys = function() {
      var _char, _keys, i;
      _keys = this;
      i = 0;
      while (i < 230) {
        _char = String.fromCharCode(i).toUpperCase();
        _keys[_char] = new Key(i);
        i++;
      }
      _keys["Space"] = new Key(32);
      _keys["LeftArrow"] = new Key(37);
      _keys["RightArrow"] = new Key(39);
      _keys["UpArrow"] = new Key(38);
      return _keys["DownArrow"] = new Key(40);
    };

    return Keys;

  })();

  Torch.Keys = Keys;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Tween, TweenManager, TweenSetup;

  Torch.Easing = Torch.Enum("Linear", "Square", "Cube", "InverseSquare", "InverseCube", "Smooth", "SmoothSquare", "SmoothCube", "Sine", "InverseSine");

  Tween = (function() {
    Tween.MixIn(Trashable);

    Tween.MixIn(EventDispatcher);

    Tween.prototype.objectToTween = null;

    Tween.prototype.tweenProperties = null;

    Tween.prototype.originalObjectValues = null;

    Tween.prototype.elapsedTime = 0;

    Tween.prototype.timeTweenShouldTake = 0;

    Tween.prototype.easing = null;

    function Tween(game, objectToTween, tweenProperties1, timeTweenShouldTake1, easing) {
      var key, ref, value;
      this.game = game;
      this.objectToTween = objectToTween;
      this.tweenProperties = tweenProperties1;
      this.timeTweenShouldTake = timeTweenShouldTake1;
      this.easing = easing;
      this.InitEventDispatch();
      this.game.Tweens.tweens.push(this);
      this.originalObjectValues = {};
      ref = this.tweenProperties;
      for (key in ref) {
        value = ref[key];
        this.originalObjectValues[key] = this.objectToTween[key];
      }
    }

    Tween.prototype.Update = function() {
      var easedTime, key, normalizedTime, ref, value;
      normalizedTime = this.elapsedTime / this.timeTweenShouldTake;
      easedTime = this.Ease(normalizedTime);
      ref = this.tweenProperties;
      for (key in ref) {
        value = ref[key];
        this.objectToTween[key] = (this.tweenProperties[key] * easedTime) + (this.originalObjectValues[key] * (1 - easedTime));
      }
      this.elapsedTime += this.game.Loop.updateDelta;
      if (this.elapsedTime >= this.timeTweenShouldTake) {
        this.Emit("Finish", new Torch.Event(this.game, {
          tween: this
        }));
        return this.Trash();
      }
    };

    Tween.prototype.Ease = function(normalizedTime) {
      switch (this.easing) {
        case Torch.Easing.Linear:
          return normalizedTime;
        case Torch.Easing.Square:
          return Math.pow(normalizedTime, 2);
        case Torch.Easing.Cube:
          return Math.pow(normalizedTime, 3);
        case Torch.Easing.InverseSquare:
          return 1 - Math.pow(1 - normalizedTime, 2);
        case Torch.Easing.InverseCube:
          return 1 - Math.pow(1 - normalizedTime, 3);
        case Torch.Easing.Smooth:
          return normalizedTime * normalizedTime * (3 - 2 * normalizedTime);
        case Torch.Easing.SmoothSquare:
          return Math.pow(normalizedTime * normalizedTime * (3 - 2 * normalizedTime), 2);
        case Torch.Easing.SmoothCube:
          return Math.pow(normalizedTime * normalizedTime * (3 - 2 * normalizedTime), 3);
        case Torch.Easing.Sine:
          return Math.sin(normalizedTime * Math.PI / 2);
        case Torch.Easing.InverseSine:
          return 1 - Math.sin((1 - normalizedTime) * Math.PI / 2);
      }
    };

    return Tween;

  })();

  TweenSetup = (function() {
    function TweenSetup(game, object1, timeTweenShouldTake1, easing) {
      this.game = game;
      this.object = object1;
      this.timeTweenShouldTake = timeTweenShouldTake1;
      this.easing = easing != null ? easing : Torch.Easing.Smooth;
    }

    TweenSetup.prototype.To = function(tweenProperties) {
      return new Tween(this.game, this.object, tweenProperties, this.timeTweenShouldTake, this.easing);
    };

    TweenSetup.prototype.From = function(setProperties) {
      var key, value;
      for (key in setProperties) {
        value = setProperties[key];
        this.object[key] = value;
      }
      return this;
    };

    return TweenSetup;

  })();

  TweenManager = (function() {
    function TweenManager(game) {
      this.game = game;
      this.tweens = [];
    }

    TweenManager.prototype.Update = function() {
      var cleanedTweens, i, len, ref, results, tween;
      cleanedTweens = [];
      ref = this.tweens;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        tween = ref[i];
        if (!tween.trash) {
          cleanedTweens.push(tween);
          results.push(tween.Update());
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    TweenManager.prototype.Tween = function(object, timeTweenShouldTake) {
      return new TweenSetup(this.game, object, timeTweenShouldTake);
    };

    TweenManager.prototype.All = function(callback) {
      var i, len, ref, results, tween;
      ref = this.game.tweens;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        tween = ref[i];
        results.push(callback(tween));
      }
      return results;
    };

    return TweenManager;

  })();

  Torch.TweenManager = TweenManager;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var ParticleEmitter, ParticleManager,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ParticleEmitter = (function(superClass) {
    extend(ParticleEmitter, superClass);

    ParticleEmitter.prototype.particle = null;

    ParticleEmitter.prototype.auto = true;

    function ParticleEmitter(game, x, y, interval1, loop, particle1, config1) {
      this.game = game;
      this.interval = interval1;
      this.loop = loop;
      this.particle = particle1;
      this.config = config1;
      this.InitSprite(this.game, x, y);
      this.elapsedTime = 0;
      this.hasEmitted = false;
    }

    ParticleEmitter.prototype.Update = function() {
      ParticleEmitter.__super__.Update.call(this);
      if (this.interval !== void 0) {
        if (this.hasEmitted) {
          if (this.loop) {
            return this.UpdateParticleEmitter();
          }
        } else {
          return this.UpdateParticleEmitter();
        }
      }
    };

    ParticleEmitter.prototype.Particle = function(particle) {
      return particle = particle;
    };

    ParticleEmitter.prototype.UpdateParticleEmitter = function() {
      if (!this.auto) {
        return;
      }
      this.elapsedTime += this.game.Loop.updateDelta;
      if (this.elapsedTime >= this.interval) {
        this.EmitParticles();
        this.hasEmitted = true;
        return this.elapsedTime = 0;
      }
    };

    ParticleEmitter.prototype.EmitParticles = function() {
      var i, results;
      i = 0;
      results = [];
      while (i < this.config.spread) {
        i++;
        results.push(this.EmitParticle());
      }
      return results;
    };

    ParticleEmitter.prototype.EmitParticle = function() {
      var alphaDecay, angle, p, radius, scale, x, y;
      angle = Torch.RandomInRange(this.config.minAngle, this.config.maxAngle);
      scale = Torch.RandomInRange(this.config.minScale, this.config.maxScale);
      alphaDecay = Torch.RandomInRange(this.config.minAlphaDecay, this.config.maxAlphaDecay);
      radius = Torch.RandomInRange(this.config.minRadius, this.config.maxRadius);
      x = this.position.x;
      y = this.position.y;
      if (typeof this.particle !== "string") {
        p = new this.particle(this.game, x, y);
      } else {
        p = new Torch.Sprite(this.game, x, y);
        p.Bind.Texture(this.particle);
      }
      p.Body.velocity.x = Math.cos(angle) * Torch.RandomInRange(this.config.minVelocity, this.config.maxVelocity);
      p.Body.velocity.y = Math.sin(angle) * Torch.RandomInRange(this.config.minVelocity, this.config.maxVelocity);
      p.Body.omega = Torch.RandomInRange(this.config.minOmega, this.config.maxOmega);
      p.Size.scale.width = scale;
      p.Size.scale.height = scale;
      p.drawIndex = 1000;
      return this.game.Tweens.Tween(p, alphaDecay, Torch.Easing.Smooth).To({
        opacity: 0
      }).On("Finish", function() {
        return p.Trash();
      });
    };

    return ParticleEmitter;

  })(Torch.Sprite);

  ParticleManager = (function() {
    function ParticleManager(game) {
      this.game = game;
    }

    ParticleManager.prototype.ParticleEmitter = function(x, y, interval, shouldLoop, particle, config) {
      return new ParticleEmitter(this.game, x, y, interval, shouldLoop, particle, config);
    };

    return ParticleManager;

  })();

  Torch.ParticleManager = ParticleManager;

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    @class Torch.Game
    @author roonilwazlib

    @constructor
        @param canvasId, string, REQUIRED
        @param width, number|string, REQUIRED
        @param height, number|string, REQUIRED
        @param name, string, REQUIRED
        @param graphicsType, enum, REQUIRED
        @param pixel, enum

    @description
        Torch.Canvas game controls the base behavior of a Torch game. The gameloop,
        asset loading, and initialization are handled here. Torch.CanvasGame
        dictates the HTML5 2d canvas be used for rendering, as opposed to WEBGL
 */

(function() {
  var CanvasGame;

  CanvasGame = (function() {
    function CanvasGame(canvasId, width, height, name, graphicsType, pixel) {
      this.canvasId = canvasId;
      this.width = width;
      this.height = height;
      this.name = name;
      this.graphicsType = graphicsType;
      this.pixel = pixel != null ? pixel : 0;
      this.InitGame();
    }

    CanvasGame.MixIn(Torch.EventDispatcher);

    CanvasGame.prototype.InitGame = function() {
      this.InitEventDispatch();
      this.InitGraphics();
      return this.InitComponents();
    };

    CanvasGame.prototype.InitComponents = function() {
      var graphicsString, styleString;
      styleString = "background-color:orange; color:white; padding:2px; padding-right:5px;padding-left:5px";
      graphicsString = "WebGL";
      if (this.graphicsType === Torch.CANVAS) {
        graphicsString = "Canvas";
      }
      console.log("%c Torch v" + Torch.version + " |" + graphicsString + "| - " + this.name, styleString);
      this.Loop = new Torch.Loop(this);
      this.Load = new Torch.Load(this);
      this.Viewport = new Torch.Viewport(this);
      this.Mouse = new Torch.Mouse(this);
      this.Timer = new Torch.Timer(this);
      this.Camera = new Torch.Camera(this);
      this.Layers = new Torch.Layers(this);
      this.Debug = new Torch.Debug(this);
      this.Keys = new Torch.Keys(this);
      this.Tweens = new Torch.TweenManager(this);
      this.Particles = new Torch.ParticleManager(this);
      Torch.Style();
      this.deltaTime = 0;
      this.fps = 0;
      this.averageFps = 0;
      this.allFPS = 0;
      this.ticks = 0;
      this.zoom = 1;
      this.uidCounter = 0;
      this.paused = false;
      this.time = null;
      this.LastTimeStamp = null;
      this.spriteList = [];
      this.threeList = [];
      this.taskList = [];
      this.animations = [];
      this.tweens = [];
      this.DrawStack = [];
      this.AddStack = [];
      this.GamePads = [];
      this.events = {};
      return this.filter = {};
    };

    CanvasGame.prototype.InitGraphics = function() {
      this.canvasNode = document.createElement("CANVAS");
      this.canvasNode.width = window.innerWidth;
      this.canvasNode.height = window.innerHeight;
      document.getElementById(this.canvasId).appendChild(this.canvasNode);
      this.canvas = this.canvasNode.getContext("2d");
      return this.Clear("#cc5200");
    };

    CanvasGame.prototype.PixelScale = function() {
      this.canvas.webkitImageSmoothingEnabled = false;
      this.canvas.mozImageSmoothingEnabled = false;
      this.canvas.imageSmoothingEnabled = false;
      return this;
    };

    CanvasGame.prototype.Bounds = function(boundRec) {
      if (boundRec === void 0) {
        this.BoundRec = this.Viewport.GetViewRectangle();
      }
      return this;
    };

    CanvasGame.prototype.Start = function(load, update, draw, init) {
      if (load === void 0) {
        this.FatalError("Unable to start game '" + this.name + "' without load function");
      }
      if (update === void 0) {
        this.FatalError("Unable to start game '" + this.name + "' without update function");
      }
      if (draw === void 0) {
        this.FatalError("Unable to start game '" + this.name + "' without draw function");
      }
      if (init === void 0) {
        this.FatalError("Unable to start game '" + this.name + "' without update function");
      }
      this.load = load;
      this.update = update;
      this.draw = draw;
      this.init = init;
      this.load(this);
      this.Load.Load((function(_this) {
        return function() {
          _this.init(_this);
          _this.WireUpEvents();
          return _this.Run();
        };
      })(this));
      if (this.graphicsType === Torch.WEBGL) {
        return;
      }
      this.canvasNode.width = this.width;
      this.canvasNode.height = this.height;
      if (typeof this.width === "string") {
        this.canvasNode.width = document.body.clientWidth - 50;
      }
      if (typeof this.height === "string") {
        this.canvasNode.height = document.body.clientHeight - 25;
      }
      this.Viewport.width = this.canvasNode.width;
      return this.Viewport.height = this.canvasNode.height;
    };

    CanvasGame.prototype.Add = function(o) {
      if (o === void 0 || o._torch_add === void 0) {
        this.FatalError("Cannot add object: " + o.constructor.name + " to game");
      }
      if (o._torch_add === "Sprite") {
        o._torch_uid = "TORCHSPRITE" + this.uidCounter.toString();
        o._torch_add_order = this.uidCounter;
        this.AddStack.push(o);
        return this.uidCounter++;
      } else if (o._torch_add === "Three") {
        o.game = this;
        return this.gl_scene.add(o.entity);
      } else if (o._torch_add === "Task") {
        return this.taskList.push(o);
      }
    };

    CanvasGame.prototype.Task = function(task) {
      this.taskList.push(task);
      return this;
    };

    CanvasGame.prototype.Run = function(timestamp) {
      return this.Loop.Run(0);
    };

    CanvasGame.prototype.FlushSprites = function() {
      var i, len, ref, results, sprite;
      ref = this.spriteList;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        results.push(sprite.Trash());
      }
      return results;
    };

    CanvasGame.prototype.FatalError = function(error) {
      var errorHtml, stack;
      if (this.fatal) {
        return;
      }
      this.fatal = true;
      if (typeof error === "string") {
        error = new Error(error);
      }
      this.Clear("#000");
      stack = error.stack.replace(/\n/g, "<br><br>");
      errorHtml = "<code style='color:#C9302Cmargin-left:15%font-size:24px'>" + error + "</code>\n<br>\n<code style='color:#C9302Cfont-size:20pxfont-weight:bold'>Stack Trace:</code>\n<br>\n<code style='color:#C9302Cfont-size:20px'>" + stack + "</code>\n<br>\n<code style='color:#C9302Cfont-size:18px'>Time: " + this.time + "</code>";
      document.body.innerHTML = errorHtml;
      this.RunGame = function() {};
      this.Run = function() {};
      this.Emit("FatalError", new Torch.Event(this, {
        error: error
      }));
      throw error;
    };

    CanvasGame.prototype.UpdateTasks = function() {
      var cleanedTasks, i, len, ref, task;
      cleanedTasks = [];
      ref = this.taskList;
      for (i = 0, len = ref.length; i < len; i++) {
        task = ref[i];
        task.Execute(this);
        if (!task.trash) {
          cleanedTasks.push(task);
        }
      }
      return this.taskList = cleanedTasks;
    };

    CanvasGame.prototype.UpdateSprites = function() {
      var cleanedSprites, i, j, len, len1, o, ref, ref1, sprite;
      cleanedSprites = [];
      ref = this.spriteList;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        if (!sprite.trash) {
          if (!sprite.game.paused) {
            sprite.Update();
          }
          cleanedSprites.push(sprite);
        } else {
          sprite.trashed = true;
          sprite.Emit("Trash", new Torch.Event(this));
        }
      }
      this.spriteList = cleanedSprites;
      ref1 = this.AddStack;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        o = ref1[j];
        this.spriteList.push(o);
      }
      return this.AddStack = [];
    };

    CanvasGame.prototype.DrawSprites = function() {
      var i, len, ref, results, sprite;
      this.canvas.clearRect(0, 0, this.Viewport.width, this.Viewport.height);
      this.spriteList.sort(function(a, b) {
        if (a.drawIndex === b.drawIndex) {
          return a._torch_add_order - b._torch_add_order;
        }
        return a.drawIndex - b.drawIndex;
      });
      ref = this.spriteList;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        if (sprite.draw && !sprite.trash && !sprite.GHOST_SPRITE) {
          results.push(sprite.Draw());
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    CanvasGame.prototype.UpdateAnimations = function() {
      var anim, i, len, ref, results;
      ref = this.animations;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        anim = ref[i];
        results.push(anim.Run());
      }
      return results;
    };

    CanvasGame.prototype.UpdateTimeInfo = function() {
      this.fps = Math.round(1000 / this.deltaTime);
      if (this.fps === Infinity) {
        this.allFPS += 0;
      } else {
        this.allFPS += Math.round(1000 / this.deltaTime);
      }
      this.ticks++;
      return this.averageFps = Math.round(this.allFPS / this.ticks);
    };

    CanvasGame.prototype.UpdateGamePads = function() {
      var i, len, pad, pads, results;
      if (navigator.getGamepads && typeof navigator.getGamepads) {
        this.GamePads = [];
        pads = navigator.getGamepads();
        results = [];
        for (i = 0, len = pads.length; i < len; i++) {
          pad = pads[i];
          if (pad) {
            results.push(this.GamePads.push(new Torch.GamePad(pad)));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    CanvasGame.prototype.Clear = function(color) {
      if (color === void 0) {
        this.FatalError("Cannot clear undefined color");
      }
      if (typeof color === "object") {
        color = color.hex;
      }
      this.canvasNode.style.backgroundColor = color;
      return this;
    };

    CanvasGame.prototype.File = function(fileId) {
      if (this.Files[fileId] === void 0) {
        return this.FatalError("Unable to access no-existent file: " + fileId + ". File does not exist");
      } else {
        return this.Files[fileId];
      }
    };

    CanvasGame.prototype.Sound = function(soundId) {
      if (this.Assets.Sounds[soundId] === void 0) {
        return this.FatalError("Unable to access no-existent file: " + soundId + ". File does not exist");
      } else {
        return this.Assets.Sounds[soundId].audio;
      }
    };

    CanvasGame.prototype.getCanvasEvents = function() {
      var evts;
      evts = [
        [
          "mousemove", (function(_this) {
            return function(e) {
              _this.Mouse.SetMousePos(_this.canvasNode, e);
              return _this.Emit("MouseMove", new Torch.Event(_this, {
                nativeEvent: e
              }));
            };
          })(this)
        ], [
          "mousedown", (function(_this) {
            return function(e) {
              _this.Mouse.down = true;
              return _this.Emit("MouseDown", new Torch.Event(_this, {
                nativeEvent: e
              }));
            };
          })(this)
        ], [
          "mouseup", (function(_this) {
            return function(e) {
              _this.Mouse.down = false;
              return _this.Emit("MouseUp", new Torch.Event(_this, {
                nativeEvent: e
              }));
            };
          })(this)
        ], [
          "touchstart", (function(_this) {
            return function(e) {
              return _this.Mouse.down = true;
            };
          })(this)
        ], [
          "touchend", (function(_this) {
            return function(e) {
              return _this.Mouse.down = false;
            };
          })(this)
        ], [
          "click", (function(_this) {
            return function(e) {
              e.preventDefault();
              e.stopPropagation();
              _this.Emit("Click", new Torch.Event(_this, {
                nativeEvent: e
              }));
              return false;
            };
          })(this)
        ]
      ];
      return evts;
    };

    CanvasGame.prototype.getBodyEvents = function() {
      var bodyEvents;
      bodyEvents = [
        [
          "keydown", (function(_this) {
            return function(e) {
              var c;
              c = e.keyCode;
              if (c === 32) {
                _this.Keys.Space.down = true;
                return _this.Keys.Space.Emit("KeyDown", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              } else if (c === 37) {
                _this.Keys.LeftArrow.down = true;
                return _this.Keys.LeftArrow.Emit("KeyDown", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              } else if (c === 38) {
                _this.Keys.UpArrow.down = true;
                return _this.Keys.UpArrow.Emit("KeyDown", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              } else if (c === 39) {
                _this.Keys.RightArrow.down = true;
                return _this.Keys.RightArrow.Emit("KeyDown", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              } else if (c === 40) {
                _this.Keys.DownArrow.down = true;
                return _this.Keys.DownArrow.Emit("KeyDown", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              } else {
                _this.Keys[String.fromCharCode(e.keyCode).toUpperCase()].down = true;
                return _this.Keys[String.fromCharCode(e.keyCode).toUpperCase()].Emit("KeyDown", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              }
            };
          })(this)
        ], [
          "keyup", (function(_this) {
            return function(e) {
              var c;
              c = e.keyCode;
              if (c === 32) {
                _this.Keys.Space.down = false;
                return _this.Keys.Space.Emit("KeyUp", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              } else if (c === 37) {
                _this.Keys.LeftArrow.down = false;
                return _this.Keys.LeftArrow.Emit("KeyUp", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              } else if (c === 38) {
                _this.Keys.UpArrow.down = false;
                return _this.Keys.UpArrow.Emit("KeyUp", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              } else if (c === 39) {
                _this.Keys.RightArrow.down = false;
                return _this.Keys.RightArrow.Emit("KeyUp", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              } else if (c === 40) {
                _this.Keys.DownArrow.down = false;
                return _this.Keys.DownArrow.Emit("KeyUp", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              } else {
                _this.Keys[String.fromCharCode(e.keyCode).toUpperCase()].down = false;
                return _this.Keys[String.fromCharCode(e.keyCode).toUpperCase()].Emit("KeyUp", new Torch.Event(_this, {
                  nativeEvent: e
                }));
              }
            };
          })(this)
        ]
      ];
      return bodyEvents;
    };

    CanvasGame.prototype.WireUpEvents = function() {
      var eventItem, i, j, len, len1, pads, ref, ref1, resize;
      ref = this.getCanvasEvents();
      for (i = 0, len = ref.length; i < len; i++) {
        eventItem = ref[i];
        this.canvasNode.addEventListener(eventItem[0], eventItem[1], false);
      }
      ref1 = this.getBodyEvents();
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        eventItem = ref1[j];
        document.body.addEventListener(eventItem[0], eventItem[1], false);
      }
      window.addEventListener("gamepadconnected", (function(_this) {
        return function(e) {
          var gp;
          gp = navigator.getGamepads()[e.gamepad.index];
          _this.GamePads.push(new Torch.GamePad(gp));
          return console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.", e.gamepad.index, e.gamepad.id, e.gamepad.buttons.length, e.gamepad.axes.length);
        };
      })(this));
      resize = (function(_this) {
        return function(event) {
          _this.Viewport.width = window.innerWidth;
          _this.Viewport.height = window.innerHeight;
          return _this.Emit("Resize", new Torch.Event(_this, {
            nativeEvent: event
          }));
        };
      })(this);
      window.addEventListener('resize', resize, false);
      return pads = navigator.getGamepads();

      /*
      for (var i = 0 i < pads.length i++)
      {
          @GamePads.push(new Torch.GamePad(pads[i]))
      }
       */
    };

    CanvasGame.prototype.TogglePause = function() {
      if (!this.paused) {
        this.paused = true;
      } else {
        this.paused = false;
      }
      return this;
    };

    return CanvasGame;

  })();

  Torch.CanvasGame = CanvasGame;

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    @class Torch.WebGLGame @extends Torch.CanvasGame
    @author roonilwazlib

    @constructor
        @param canvasId, string, REQUIRED
        @param width, number|string, REQUIRED
        @param height, number|string, REQUIRED
        @param name, string, REQUIRED
        @param graphicsType, enum, REQUIRED
        @param pixel, enum

    @description
        Torch.WebGLGame dictates that WEBGL, through three.js, be used to render
        graphics.
 */

(function() {
  var WebGLGame,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  WebGLGame = (function(superClass) {
    extend(WebGLGame, superClass);

    function WebGLGame(canvasId, width, height, name, graphicsType, pixel) {
      this.canvasId = canvasId;
      this.width = width;
      this.height = height;
      this.name = name;
      this.graphicsType = graphicsType;
      this.pixel = pixel != null ? pixel : 0;
      this.InitGame();
    }

    WebGLGame.prototype.InitGraphics = function() {
      this.gl_rendererContainer = document.getElementById(this.canvasId);
      this.gl_scene = new THREE.Scene();
      this.gl_scene.add(new THREE.AxisHelper(100));
      this.gl_camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 1000);
      this.gl_camera.position.z = 600;
      this.gl_renderer = new THREE.WebGLRenderer({
        antialias: this.pixel !== Torch.PIXEL,
        alpha: true
      });
      this.gl_renderer.setSize(window.innerWidth, window.innerHeight);
      this.gl_renderer.setPixelRatio(window.devicePixelRatio);
      this.canvasNode = this.gl_renderer.domElement;
      this.gl_rendererContainer.appendChild(this.canvasNode);
      return this.On("Resize", (function(_this) {
        return function(event) {
          _this.gl_renderer.setSize(_this.Viewport.width, _this.Viewport.height);
          _this.gl_camera.aspect = _this.Viewport.width / _this.Viewport.height;
          return _this.gl_camera.updateProjectionMatrix();
        };
      })(this));
    };

    WebGLGame.prototype.DrawSprites = function() {
      var i, len, ref, sprite;
      this.spriteList.sort(function(a, b) {
        return a.drawIndex - b.drawIndex;
      });
      ref = this.spriteList;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        if (sprite.draw && !sprite.trash && !sprite.GHOST_SPRITE) {
          sprite.Draw();
        }
        if (sprite.trash) {
          sprite.Three().Remove();
        }
      }
      this.gl_camera.lookAt(this.gl_scene.position);
      return this.gl_renderer.render(this.gl_scene, this.gl_camera);
    };

    WebGLGame.prototype.UpdateSprites = function() {
      var cleanedSprites, i, len, ref, sprite;
      cleanedSprites = [];
      ref = this.spriteList;
      for (i = 0, len = ref.length; i < len; i++) {
        sprite = ref[i];
        if (!sprite.trash) {
          if (!sprite.game.paused) {
            sprite.Update();
          }
          cleanedSprites.push(sprite);
        } else {
          if (sprite.Three() !== void 0) {
            sprite.Three().Remove();
          }
          sprite.trashed = true;
          sprite.Emit("Trash");
        }
      }
      return this.spriteList = cleanedSprites;
    };

    WebGLGame.prototype.GetThreeTransform = function(x, y) {
      var camera, dir, distance, pos, vector;
      vector = new THREE.Vector3();
      camera = this.gl_camera;
      vector.set((x / window.innerWidth) * 2 - 1, -(y / window.innerHeight) * 2 + 1, 1);
      vector.unproject(camera);
      dir = vector.sub(camera.position).normalize();
      distance = -camera.position.z / dir.z;
      pos = camera.position.clone().add(dir.multiplyScalar(distance));
      return pos;
    };

    return WebGLGame;

  })(Torch.CanvasGame);

  Torch.WebGLGame = WebGLGame;

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    @class Torch.Game
    @author roonilwazlib

    @constructor
        @param canvasId, string, REQUIRED
        @param width, number|string, REQUIRED
        @param height, number|string, REQUIRED
        @param name, string, REQUIRED
        @param graphicsType, enum, REQUIRED
        @param pixel, enum

    @description
        A weird little class, Torch.Game acts as a facade and switches either a
        Torch.WebGLGame or Torch.CanvasGame in for itself depending on the desired
        graphics type
 */

(function() {
  var Game;

  Game = (function() {
    function Game(canvasId, width, height, name, graphicsType, pixel) {
      if (graphicsType === Torch.CANVAS) {
        return new Torch.CanvasGame(canvasId, width, height, name, graphicsType, pixel);
      }
      if (graphicsType === Torch.WEBGL) {
        return new Torch.WebGLGame(canvasId, width, height, name, graphicsType, pixel);
      }
    }

    return Game;

  })();

  Torch.Game = Game;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Actor, Block, Fluid, SpawnItem, Spawner, exports,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  exports = this;

  Torch.Platformer = {
    Gravity: 0.001,
    SHIFT_COLLIDE_LEFT: 5,
    SetWorld: function(spawnItems) {
      return Torch.Platformer.spawnItems = spawnItems;
    }
  };

  Actor = (function() {
    Actor.prototype.ACTOR = true;

    Actor.prototype.Health = 100;

    Actor.prototype.currentFriction = 1;

    Actor.prototype.inFluid = false;

    Actor.prototype.onGround = false;

    Actor.prototype.onLeft = false;

    Actor.prototype.onTop = false;

    Actor.prototype.onRight = false;

    Actor.prototype.hitLockCounter = 0;

    Actor.prototype.hitLockBlinkCounter = 0;

    Actor.prototype.hitLock = false;

    Actor.prototype.hitLockMax = 1000;

    function Actor() {
      throw "Actor is a base class";
    }

    Actor.prototype.HitLock = function() {
      return this.hitLock = true;
    };

    Actor.prototype.Hit = function(amount) {
      if (amount == null) {
        amount = 1;
      }
      this.Health -= amount;
      if (this.Health <= 0) {
        return this.Die;
      }
    };

    Actor.prototype.Die = function() {
      return this.isDead = true;
    };

    Actor.prototype.BlockCollision = function(item, offset) {
      if (offset) {
        if (offset.vx < offset.halfWidths && offset.vy < offset.halfHeights) {
          if (offset.x < offset.y) {
            this.Body.Velocity("y", 0);
            if (offset.vx > 0) {
              if (!item.Sprite.Slope) {
                this.Rectangle.x += offset.x + Torch.Platformer.SHIFT_COLLIDE_LEFT;
                this.Body.Velocity("x", 0);
                return this.onLeft = true;
              } else {
                return this.BlockSlope(item.Sprite, offset);
              }
            } else if (offset.vx < 0) {
              if (!item.Sprite.Slope) {
                this.Rectangle.x -= offset.x;
                this.Body.Velocity("x", 0);
                return this.onRight = true;
              } else {
                return this.BlockSlope(item.Sprite, offset);
              }
            }
          } else if (offset.x > offset.y) {
            if (offset.vy > 0) {
              this.Rectangle.y += offset.y;
              return this.Body.Velocity("y", 0);
            } else if (offset.vy < 0) {
              if (!item.Sprite.Slope) {
                this.Rectangle.y -= offset.y - item.Sprite.sink;
                this.Body.Acceleration("y", 0).Velocity("y", 0);
                this.onGround = true;
                if (!this.inFluid) {
                  return this.currentFriction = item.Sprite.friction;
                }
              } else {
                return this.BlockSlope(item.Sprite, offset);
              }
            }
          }
        }
      }
    };

    Actor.prototype.BlockSlope = function(block, offset) {
      var Yoffset;
      Yoffset = offset.x * Math.tan(block.Slope);
      this.Rectangle.y = block.Rectangle.y + (block.Rectangle.height - Yoffset) - this.Rectangle.height;
      return this.onSlope = true;
    };

    Actor.prototype.FluidCollision = function(item, offset) {
      if (offset) {
        this.currentFriction = item.Sprite.friction;
        this.Body.y.acceleration = item.Sprite.gravity;
        return this.inFluid = true;
      }
    };

    Actor.prototype.UpdateActor = function() {
      var i, item, len, offset, rect, ref;
      this.inFluid = false;
      this.onGround = false;
      this.onTop = false;
      this.onRight = false;
      this.onLeft = false;
      ref = Torch.Platformer.spawnItems;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        rect = this.Rectangle;
        if (item.spawned && item.Sprite && item.Sprite.BLOCK && this.NotSelf(item.Sprite) && this.ACTOR) {
          offset = this.Rectangle.Intersects(item.Sprite.Rectangle);
          this.BlockCollision(item, offset);
        }
        if (item.spawned && item.Sprite && item.Sprite.FLUID && this.NotSelf(item.Sprite) && this.ACTOR) {
          offset = this.Rectangle.Intersects(item.Sprite.Rectangle);
          this.FluidCollision(item, offset);
        }
        if (!this.onGround && !this.inFluid) {
          this.Body.y.acceleration = Torch.Platformer.Gravity;
        }
      }
      if (this.hitLock) {
        this.hitLockCounter += Game.deltaTime;
        this.hitLockBlinkCounter += Game.deltaTime;
        if (this.hitLockBlinkCounter >= 200) {
          if (this.opacity === 0.1) {
            this.opacity = 0.8;
          } else {
            this.opacity = 0.1;
          }
          this.hitLockBlinkCounter = 0;
        }
        if (this.hitLockCounter >= this.hitLockMax) {
          this.hitLock = false;
          this.opacity = 1;
          this.hitLockCounter = 0;
          return this.hitLockBlinkCounter = 0;
        }
      }
    };

    return Actor;

  })();

  Block = (function() {
    Block.prototype.BLOCK = true;

    Block.prototype.friction = 1;

    Block.prototype.sink = 0;

    function Block() {
      throw "Block is a base class";
    }

    return Block;

  })();

  Fluid = (function() {
    Fluid.prototype.FLUID = true;

    Fluid.prototype.friction = 0.3;

    Fluid.prototype.gravity = 0.0001;

    Fluid.prototype.drawIndex = 30;

    function Fluid() {
      throw "Fluid is a base class";
    }

    return Fluid;

  })();

  Spawner = (function(superClass) {
    extend(Spawner, superClass);

    function Spawner(spawnItems1) {
      this.spawnItems = spawnItems1;
      Torch.Platformer.SetWorld(this.spawnItems);
    }

    return Spawner;

  })(Torch.GhostSprite);

  ({
    FlushSprites: function() {
      var i, item, len, ref, results;
      ref = this.spawnItems;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.Sprite) {
          results.push(item.Sprite.Trash());
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    Update: function() {
      var i, item, len, newRec, ref, results, spr, viewRect;
      if (this.spawnItems.length > 0) {
        viewRect = Game.Viewport.GetViewRectangle();
        ref = this.spriteList;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          if (!item.Manual) {
            newRec = {
              x: item.Sprite.Rectangle.x,
              y: item.Sprite.Rectangle.y,
              width: item.Sprite.Rectangle.width,
              height: item.Sprite.Rectangle.height
            };
            if (!item.spawned && !item.dead && item.DisableDynamicSpawning) {
              spr = this.SpawnTypes[item.SpawnType](item.Position, item, item.addData);
              item.Sprite = spr;
              item.spawned = true;
              results.push(spr.spawnItem = item);
            } else if (!item.spawned && !item.dead && viewRect.Intersects({
              x: item.Position.x,
              y: item.Position.y,
              width: item.width * Game.SCALE,
              height: item.height * Game.SCALE
            })) {
              if (item.SpawnType) {
                spr = this.SpawnTypes[item.SpawnType](item.Position, item, item.addData);
                item.Sprite = spr;
                item.spawned = true;
                results.push(spr.spawnItem = item);
              } else {
                results.push(void 0);
              }
            } else if (item.spawned && item.Sprite && item.Sprite.Rectangle && !viewRect.Intersects(newRec)) {
              item.Sprite.Trash();
              item.Sprite = null;
              results.push(item.spawned = false);
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    }
  });

  SpawnItem = (function() {
    function SpawnItem(spawnType, spawned, obj, position) {
      this.spawnType = spawnType;
      this.spawned = spawned;
      this.obj = obj;
      this.position = position;
      if (this.obj) {
        this.Sprite = this.obj;
      }
    }

    return SpawnItem;

  })();

  exports.Facing = Torch.Enum("Right", "Left");

  exports.Walking = Torch.Enum("Right", "Left", "None");

  Torch.Platformer.Actor = Actor;

  Torch.Platformer.Block = Block;

  Torch.Platformer.Fluid = Fluid;

  Torch.Platformer.Spawner = Spawner;

  Torch.Platformer.spawnItem = SpawnItem;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {


}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var PlayList,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Torch.Sound = {};

  PlayList = (function(superClass) {
    extend(PlayList, superClass);

    function PlayList(game, songList) {
      this.game = game;
      this.songList = songList;
      this.currentSong = this.songList[0];
      this.index = 0;
    }

    PlayList.prototype.Play = function() {
      this.game.Assets.GetSound(this.currentSong).volume = 0.7;
      this.game.Assets.GetSound(this.currentSong).play();
      return this;
    };

    PlayList.prototype.ShuffleArray = function(array) {
      var currentIndex, randomIndex, temporaryValue;
      currentIndex = array.length;
      temporaryValue = null;
      randomIndex = null;
      while (0 !== currentIndex) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }
      return array;
    };

    PlayList.prototype.Randomize = function() {
      this.songList = this.ShuffleArray(this.songList);
      this.currentSong = this.songList[0];
      return this;
    };

    PlayList.prototype.Update = function() {
      if (this.game.Assets.GetSound(this.currentSong).currentTime >= this.game.Assets.GetSound(this.currentSong).duration) {
        this.index++;
        this.currentSong = this.songList[this.index];
        this.Play();
        if (this.index === this.songList.length - 1) {
          return this.index = 0;
        }
      }
    };

    return PlayList;

  })(Torch.GhostSprite);

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var State, StateMachine,
    slice = [].slice;

  StateMachine = (function() {
    function StateMachine(obj) {
      this.obj = obj;
      this.currentState = null;
      this.states = {};
      this.game = this.obj.game;
    }

    StateMachine.prototype.State = function(stateName, stateObj) {
      if (stateObj === void 0) {
        if (this.states[stateName] === void 0) {
          Torch.FatalError("Unable to get state. State '" + stateName + "' has not been added to the state machine");
        }
        return this.states[stateName];
      } else {
        stateObj.stateMachine = this;
        stateObj.game = this.game;
        return this.states[stateName] = stateObj;
      }
    };

    StateMachine.prototype.Switch = function() {
      var args, newState, ref, ref1;
      newState = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (this.currentState && this.currentState.End !== void 0) {
        (ref = this.currentState).End.apply(ref, [this.obj].concat(slice.call(args)));
      }
      if (this.State(newState).Start !== void 0) {
        (ref1 = this.State(newState)).Start.apply(ref1, [this.obj].concat(slice.call(args)));
      }
      return this.currentState = this.State(newState);
    };

    StateMachine.prototype.Update = function() {
      if (this.currentState !== null && this.currentState !== void 0) {
        return this.currentState.Execute(this.obj);
      }
    };

    return StateMachine;

  })();

  State = (function() {
    function State(Execute, Start, End) {
      this.Execute = Execute;
      this.Start = Start;
      this.End = End;
    }

    return State;

  })();

  Torch.StateMachine = StateMachine;

  Torch.StateMachine.State = State;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Bind, CanvasBind, WebGLBind,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Bind = (function() {
    function Bind(sprite) {
      if (sprite.GL) {
        return new WebGLBind(sprite);
      }
      return new CanvasBind(sprite);
    }

    return Bind;

  })();

  CanvasBind = (function() {
    function CanvasBind(sprite1) {
      this.sprite = sprite1;
    }

    CanvasBind.prototype.Reset = function() {
      if (this.sprite.TextureSheetAnimation) {
        this.sprite.TextureSheetAnimation.Stop();
        this.sprite.anim = null;
        this.sprite.TextureSheet = null;
      }
      if (this.sprite.TexturePackAnimation) {
        this.sprite.TexturePackAnimation.Stop();
        this.sprite.anim = null;
        return this.sprite.TexturePack = null;
      }
    };

    CanvasBind.prototype.Texture = function(textureId, optionalParameters) {
      var scale, tex;
      tex = null;
      if (typeof textureId === "string") {
        tex = this.sprite.game.Assets.Textures[textureId];
        if (!tex) {
          this.sprite.game.FatalError("Sprite.Bind.Texture given textureId '" + textureId + "' was not found");
        }
      } else {
        tex = textureId;
      }
      scale = 1;
      this.Reset();
      if (Torch.Scale && !this.sprite.TEXT) {
        this.sprite.Size.Scale(Torch.Scale, Torch.Scale);
      }
      if (typeof textureId === "string") {
        this.sprite.DrawTexture = tex;
      } else {
        this.sprite.DrawTexture = {
          image: textureId
        };
      }
      this.sprite.Size.Set(tex.width, tex.height);
      return this.sprite.DrawTexture;
    };

    CanvasBind.prototype.TexturePack = function() {

      /*
      this whole thing needs to be re-written
      here is the old javascript:
      
          var that = this;
      
          if (!optionalParameters) optionalParameters = {};
      
          var texturePack = @sprite.game.Assets.TexturePacks[texturePackId];
          if (!texturePack)
          {
              @sprite.game.FatalError(new Error("Sprite.Bind.TexturePack given texturePackId '{0}' was not found".format(texturePackId)));
          }
          else
          {
              @sprite.TexturePack = texturePack;
          }
          var anim = new Torch.Animation.TexturePack(@sprite.TexturePack, @sprite.game);
      
          if (optionalParameters.step) anim.step = optionalParameters.step;
      
          anim.Start();
          @sprite.TexturePackAnimation = anim;
          @sprite.Rectangle.width = anim.GetCurrentFrame().width;
          @sprite.Rectangle.height = anim.GetCurrentFrame().height;
          return anim;
       */
    };

    CanvasBind.prototype.TextureSheet = function(textureSheetId, optionalParameters) {
      var anim, drawTexture, textureSheet;
      if (optionalParameters == null) {
        optionalParameters = {};
      }
      textureSheet = this.sprite.game.Assets.TextureSheets[textureSheetId];
      drawTexture = this.sprite.game.Assets.Textures[textureSheetId];
      if (!textureSheet || !drawTexture) {
        this.sprite.game.FatalError("Sprite.Bind.TextureSheet given textureSheetId '" + textureSheetId + "' was not found");
      } else {
        this.sprite.DrawTexture = drawTexture;
        this.sprite.TextureSheet = textureSheet;
      }
      anim = new Torch.Animation.TextureSheet(this.sprite.TextureSheet, this.sprite.game);
      anim.sprite = this.sprite;
      if (optionalParameters.delay) {
        anim.delay = optionalParameters.delay;
        anim.delayCount = anim.delay;
      }
      if (optionalParameters.step) {
        anim.step = optionalParameters.step;
      }
      anim.Start();
      this.sprite.TextureSheetAnimation = anim;
      this.sprite.rectangle.width = anim.GetCurrentFrame().clipWidth * Torch.Scale;
      this.sprite.rectangle.height = anim.GetCurrentFrame().clipHeight * Torch.Scale;
      return anim;
    };

    return CanvasBind;

  })();

  WebGLBind = (function(superClass) {
    extend(WebGLBind, superClass);

    function WebGLBind(sprite1) {
      this.sprite = sprite1;
    }

    WebGLBind.prototype.Texture = function(textureId) {
      var height, map, material, texture, width;
      texture = null;
      map = null;
      if (textureId.gl_2d_canvas_generated_image) {
        texture = textureId;
        map = textureId.texture;
      } else {
        texture = this.sprite.game.Assets.Textures[textureId];
        map = this.sprite.game.Assets.Textures[textureId].gl_texture;
      }
      if (!this.sprite.Scale()) {
        width = texture.width * Torch.Scale;
        height = texture.height * Torch.Scale;
      } else {
        width = texture.width * this.sprite.Scale();
        height = texture.height * this.sprite.Scale();
      }
      this.sprite.gl_shape = new THREE.PlaneGeometry(width, height, 8, 8);
      material = new THREE.MeshPhongMaterial({
        map: map
      });
      material.transparent = true;
      this.sprite.gl_three_sprite = new Torch.ThreeSprite(this.sprite, material, this.sprite.gl_shape);
      this.sprite.gl_orig_width = width;
      this.sprite.gl_orig_height = height;
      this.sprite.rectangle.width = width;
      return this.sprite.rectangle.height = height;
    };

    return WebGLBind;

  })(CanvasBind);

  Torch.Bind = Bind;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Animation, StepAnimation, TexturePack, TextureSheet,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Animation = (function() {
    function Animation(game1) {
      this.game = game1;
    }

    Animation.prototype.Run = function() {
      if (this.animating) {
        this.Update();
      }
      if (this.Kill && this.hasRun) {
        return this.Stop();
      }
    };

    Animation.prototype.Start = function() {
      return this.animating = true;
    };

    Animation.prototype.Stop = function() {
      return this.animating = false;
    };

    Animation.prototype.Single = function() {
      this.KillOnFirstRun = true;
      return this.animating = true;
    };

    Animation.prototype.Reset = function() {
      this.elapsedTime = 0;
      this.textureListIndex = 0;
      return this.hasRun = false;
    };

    return Animation;

  })();

  TexturePack = (function(superClass) {
    extend(TexturePack, superClass);

    function TexturePack(texturePack1, game1) {
      this.texturePack = texturePack1;
      this.game = game1;
      this.step = 50;
      this.maxIndex = texturePack.length - 1;
      this.textureIndex = 0;
      this.elapsedTime = 0;
      this.game.animations.push(this);
    }

    TexturePack.prototype.Update = function() {
      this.elapsedTime += this.game.deltaTime;
      if (this.elapsedTime >= this.step) {
        this.elapsedTime = 0;
        this.textureIndex++;
      }
      if (this.textureIndex > this.maxIndex) {
        if (!this.Kill) {
          this.textureIndex = 0;
        }
        if (this.Kill) {
          this.textureIndex = -1;
        }
        return this.hasRun = true;
      }
    };

    TexturePack.prototype.GetCurrentFrame = function() {
      return this.game.Assets.Textures[this.texturePack[this.textureIndex]];
    };

    return TexturePack;

  })(Animation);

  TextureSheet = (function(superClass) {
    extend(TextureSheet, superClass);

    function TextureSheet(TextureSheet1, game1) {
      this.TextureSheet = TextureSheet1;
      this.game = game1;
      this.step = 50;
      this.maxIndex = this.TextureSheet.length - 1;
      this.textureIndex = 0;
      this.elapsedTime = 0;
      this.delay = 0;
      this.delayCount = 0;
      this.onStep = null;
      this.game.animations.push(this);
    }

    TextureSheet.prototype.Update = function() {
      this.elapsedTime += this.game.deltaTime;
      if (this.elapsedTime >= this.step && !(this.hasRun && this.Kill)) {
        this.elapsedTime = 0;
        this.textureIndex++;
        if (this.onStep) {
          this.onStep(this.textureIndex);
        }
      }
      if (this.textureIndex >= this.maxIndex && this.delayCount <= 0) {
        if (!this.Kill) {
          this.textureIndex = 0;
        }
        this.hasRun = true;
        if (this.finishCallBack) {
          this.finishCallBack();
        }
        return this.delayCount = this.delay;
      } else if (this.textureIndex >= this.maxIndex) {
        this.delayCount -= Game.deltaTime;
        return this.textureIndex--;
      }
    };

    TextureSheet.prototype.GetCurrentFrame = function() {
      if (this.TextureSheet) {
        return this.TextureSheet[this.textureIndex];
      }
    };

    TextureSheet.prototype.Step = function(step, onStep) {
      if (step === void 0) {
        return this.step;
      } else {
        this.step = step;
        if (onStep !== void 0) {
          this.onStep = onStep;
        }
      }
      return this;
    };

    return TextureSheet;

  })(Animation);

  StepAnimation = (function(superClass) {
    extend(StepAnimation, superClass);

    function StepAnimation(game, totalTime, steps, start, end) {
      this.InitSprite(game, 0, 0);
      this.steps = steps;
      this.totalTime = totalTime;
      this.interval = totalTime / steps.length;
      this.time = 0;
      this.index = 0;
      this.steps[0]();
      this.start = start;
      this.end = end;
      if (start) {
        this.start();
      }
    }

    StepAnimation.prototype.Update = function() {
      this.time += this.game.deltaTime;
      if (this.time >= this.interval) {
        this.time = 0;
        this.index++;
        this.steps[this.index]();
        if (this.index === this.steps.length - 1) {
          if (this.end) {
            this.end();
          }
          return this.Trash();
        }
      }
    };

    return StepAnimation;

  })(Torch.GhostSprite);

  Torch.Animation = Animation;

  Torch.Animation.TextureSheet = TextureSheet;

  Torch.Animation.TexturePack = TexturePack;

  Torch.Animation.StepAnimation = StepAnimation;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Color;

  Color = (function() {
    function Color(rOrHex, g, b, a) {
      this.hex = "";
      this.Red = 0;
      this.Green = 0;
      this.Blue = 0;
      this.Alpha = 1;
      this.Init(rOrHex, g, b, a);
    }

    Color.prototype.Init = function(rOrHex, g, b, a) {
      if (g === void 0 && g !== null) {
        return this.GetHexFromRGB(rOrHex, g, b, a);
      } else {
        return this.GetRGBFromHex(rOrHex);
      }
    };

    Color.prototype.GetHexadecimal = function(dec, a) {
      var hexa;
      hexa = Math.round(dec * a).toString(16);
      if (hexa.length === 1) {
        hexa = "0" + hexa;
      }
      return hexa;
    };

    Color.prototype.GetHexFromRGB = function(r, g, b, a) {
      this.Red = r;
      this.Green = g;
      this.Blue = b;
      this.Alpha = a;
      return this.hex = "#" + this.GetHexadecimal(r, a) + this.GetHexadecimal(g, a) + this.GetHexadecimal(b, a);
    };

    Color.prototype.GetRGBFromHex = function() {};

    Color.prototype.BlendHex = function() {
      return this.GetRGBFromHex(this.hex);
    };

    Color.prototype.BlendRGB = function() {
      return this.GetHexFromRGB(this.Red, this.Green, this.Blue, this.Alpha);
    };

    Color.prototype.GetRGBString = function() {
      return "rgba(" + this.Red + "," + this.Green + "," + this.Blue + "," + this.Alpha + ");";
    };

    return Color;

  })();

  Color.Red = new Color(256, 0, 0, 1);

  Color.Green = new Color(0, 256, 0, 1);

  Color.Blue = new Color(0, 0, 256, 1);

  Color.Flame = new Color("#ff8000");

  Color.Ruby = new Color("#e60000");

  Torch.Color = Color;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Electron;

  Electron = (function() {
    function Electron() {}

    Electron.Import = function() {
      Torch.ELECTRON = true;
      return Torch.fs = require("fs");
    };

    return Electron;

  })();

  Torch.Electron = new Electron();

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var CanvasRenderer, exports;

  exports = this;

  CanvasRenderer = (function() {
    function CanvasRenderer(sprite) {
      this.sprite = sprite;
      this.game = this.sprite.game;
      this.previousPosition = new Torch.Point(this.sprite.position.x, this.sprite.position.y);
    }

    CanvasRenderer.prototype.Draw = function() {
      var cameraTransform, drawRec, frame;
      drawRec = new Torch.Rectangle(this.sprite.position.x, this.sprite.position.y, this.sprite.rectangle.width, this.sprite.rectangle.height);
      drawRec.x = (this.sprite.position.x - this.previousPosition.x) * this.game.Loop.lagOffset + this.previousPosition.x;
      drawRec.y = (this.sprite.position.y - this.previousPosition.y) * this.game.Loop.lagOffset + this.previousPosition.y;
      this.previousPosition = new Torch.Point(this.sprite.position.x, this.sprite.position.y);
      cameraTransform = new Torch.Point(0, 0);
      if (!this.sprite.fixed) {
        drawRec.x += this.game.Camera.position.x;
        drawRec.y += this.game.Camera.position.y;
      }
      if (this.sprite.TextureSheet) {
        frame = this.sprite.GetCurrentDraw();
        this.PreRender(drawRec);
        canvas.drawImage(this.sprite.DrawTexture.image, frame.clipX, frame.clipY, frame.clipWidth, frame.clipHeight, -drawRec.width / 2, -drawRec.height / 2, drawRec.width, drawRec.height);
        return this.PostRender();
      } else if (this.sprite.DrawTexture) {
        this.PreRender(drawRec);
        this.game.canvas.drawImage(this.sprite.DrawTexture.image, -drawRec.width / 2, -drawRec.height / 2, drawRec.width, drawRec.height);
        if (this.sprite.Body.DEBUG && false) {
          this.game.canvas.fillStyle = "green";
          this.game.canvas.globalAlpha = 0.5;
          this.game.canvas.fillRect(-drawRec.width / 2, -drawRec.height / 2, drawRec.width, drawRec.height);
        }
        return this.PostRender();
      }
    };

    CanvasRenderer.prototype.PreRender = function(drawRec) {
      var canvas;
      canvas = this.game.canvas;
      canvas.save();
      canvas.translate(drawRec.x + drawRec.width / 2, drawRec.y + drawRec.height / 2);
      if (this.sprite.Effects.tint.color !== null) {
        this.game.canvas.fillStyle = this.sprite.Effects.tint.color;
        this.game.canvas.globalAlpha = this.sprite.Effects.tint.opacity;
        this.game.canvas.globalCompositeOperation = "destination-atop";
        this.game.canvas.fillRect(-drawRec.width / 2, -drawRec.height / 2, drawRec.width, drawRec.height);
      }
      canvas.globalAlpha = this.sprite.opacity;
      return canvas.rotate(this.sprite.rotation);
    };

    CanvasRenderer.prototype.PostRender = function() {
      var canvas;
      canvas = this.game.canvas;
      return canvas.restore();
    };

    return CanvasRenderer;

  })();

  exports.CanvasRenderer = CanvasRenderer;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Point, Rectangle, Vector;

  Rectangle = (function() {
    function Rectangle(x1, y1, width, height) {
      this.x = x1;
      this.y = y1;
      this.width = width;
      this.height = height;
      this.z = 0;
    }

    Rectangle.prototype.GetOffset = function(rectangle) {
      var halfHeights, halfWidths, offset, sharedXPlane, sharedYPlane, vx, vy;
      vx = (this.x + (this.width / 2)) - (rectangle.x + (rectangle.width / 2));
      vy = (this.y + (this.height / 2)) - (rectangle.y + (rectangle.height / 2));
      halfWidths = (this.width / 2) + (rectangle.width / 2);
      halfHeights = (this.height / 2) + (rectangle.height / 2);
      sharedXPlane = (this.x + this.width) - (rectangle.x + rectangle.width);
      sharedYPlane = (this.y + this.height) - (rectangle.y + rectangle.height);
      offset = {
        x: halfWidths - Math.abs(vx),
        y: halfHeights - Math.abs(vy),
        vx: vx,
        vy: vy,
        halfWidths: halfWidths,
        halfHeights: halfHeights,
        sharedXPlane: sharedXPlane,
        sharedYPlane: sharedYPlane
      };
      return offset;
    };

    Rectangle.prototype.Intersects = function(rectangle) {
      var a, b;
      a = this;
      b = rectangle;
      if (a.x < (b.x + b.width) && (a.x + a.width) > b.x && a.y < (b.y + b.height) && (a.y + a.height) > b.y) {
        return a.GetOffset(b);
      } else {
        return false;
      }
    };

    Rectangle.prototype.ShiftFrom = function(rectangle, transX, transY) {
      var x, y;
      x = null;
      y = null;
      if (transX === void 0) {
        x = rectangle.x;
      } else {
        x = rectangle.x + transX;
      }
      if (transY === void 0) {
        y = rectangle.y;
      } else {
        y = rectangle.y + transY;
      }
      this.x = x;
      return this.y = y;
    };

    return Rectangle;

  })();

  Vector = (function() {
    Vector.prototype.x = null;

    Vector.prototype.y = null;

    Vector.prototype.angle = null;

    Vector.prototype.magnitude = null;

    function Vector(x1, y1) {
      this.x = x1;
      this.y = y1;
      this.ResolveVectorProperties();
    }

    Vector.prototype.ResolveVectorProperties = function() {
      this.magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
      return this.angle = Math.atan2(this.x, this.y);
    };

    Vector.prototype.Clone = function() {
      return new Torch.Vector(this.x, this.y);
    };

    Vector.prototype.Set = function(x, y) {
      this.x = x;
      this.y = y;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.AddScalar = function(n) {
      this.x += n;
      this.y += n;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.MultiplyScalar = function(n) {
      this.x *= n;
      this.y *= n;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.DivideScalar = function(n) {
      this.x /= n;
      this.y /= n;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.SubtractVector = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.AddVector = function(v) {
      this.x += v.x;
      this.y += v.y;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.Normalize = function() {
      return this.DivideScalar(this.magnitude);
    };

    Vector.prototype.DotProduct = function(v) {
      return this.x * v.x + this.y * v.y;
    };

    Vector.prototype.IsPerpendicular = function(v) {
      return this.DotProduct(v) === 0;
    };

    Vector.prototype.IsSameDirection = function(v) {
      return this.DotProduct(v) > 0;
    };

    return Vector;

  })();

  Point = (function() {
    function Point(x1, y1, z) {
      this.x = x1;
      this.y = y1;
      this.z = z != null ? z : 0;
    }

    Point.prototype.Apply = function(point) {
      this.x += point.x;
      return this.y += point.y;
    };

    Point.prototype.Clone = function() {
      return new Point(this.x, this.y);
    };

    return Point;

  })();

  Torch.Rectangle = Rectangle;

  Torch.Vector = Vector;

  Torch.Point = Point;

}).call(this);

Torch.version = '0.5.133'